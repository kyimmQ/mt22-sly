Grammar:

Rule 0     S' -> program
Rule 1     program -> decllist
Rule 2     decllist -> decl decllist
Rule 3     decllist -> decl
Rule 4     decl -> funcdecl
Rule 5     decl -> vardecl
Rule 6     vardecl -> ID subvardecl exp0 SEMICOLON
Rule 7     vardecl -> ID subvardecl
Rule 8     vardecl -> ID COLON typeof SEMICOLON
Rule 9     subvardecl -> COLON typeof SEMICOLON
Rule 10    subvardecl -> COMMA ID subvardecl
Rule 11    subvardecl -> COLON typeof ASSIGNMENT
Rule 12    subvardecl -> COMMA ID subvardecl exp0 COMMA
Rule 13    idlist -> ID
Rule 14    idlist -> ID COMMA idlist
Rule 15    typeof -> arrtype
Rule 16    typeof -> atotype
Rule 17    typeof -> AUTO
Rule 18    atotype -> STRING
Rule 19    atotype -> FLOAT
Rule 20    atotype -> INTEGER
Rule 21    atotype -> BOOLEAN
Rule 22    arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype
Rule 23    dime -> INTLIT
Rule 24    dime -> INTLIT COMMA dime
Rule 25    returntype -> arrtype
Rule 26    returntype -> atotype
Rule 27    returntype -> VOID
Rule 28    returntype -> AUTO
Rule 29    funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt
Rule 30    funcdecl -> ID COLON FUNCTION returntype paramdecl blockstmt
Rule 31    paramdecl -> LPAREN paramlist RPAREN
Rule 32    paramlist -> empty
Rule 33    paramlist -> paramprime
Rule 34    paramprime -> param
Rule 35    paramprime -> param COMMA paramprime
Rule 36    param -> OUT ID COLON typeof
Rule 37    param -> INHERIT ID COLON typeof
Rule 38    param -> ID COLON typeof
Rule 39    param -> INHERIT OUT ID COLON typeof
Rule 40    stmtlist -> empty
Rule 41    stmtlist -> stmtprime
Rule 42    stmtprime -> stmt
Rule 43    stmtprime -> vardecl
Rule 44    stmtprime -> vardecl stmtlist
Rule 45    stmtprime -> stmt stmtlist
Rule 46    stmt -> matchstmt
Rule 47    stmt -> unmatchif
Rule 48    matchstmt -> blockstmt
Rule 49    matchstmt -> callstmt
Rule 50    matchstmt -> retstmt
Rule 51    matchstmt -> contistmt
Rule 52    matchstmt -> breakstmt
Rule 53    matchstmt -> dowhilestmt
Rule 54    matchstmt -> whilestmt
Rule 55    matchstmt -> forstmt
Rule 56    matchstmt -> matchif
Rule 57    matchstmt -> assigstmt
Rule 58    assigstmt -> ID ASSIGNMENT exp0 SEMICOLON
Rule 59    assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
Rule 60    matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
Rule 61    unmatchif -> IF LPAREN exp0 RPAREN stmt
Rule 62    unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
Rule 63    forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
Rule 64    scaladecl -> scalavar ASSIGNMENT exp0
Rule 65    scalavar -> ID
Rule 66    condifor -> exp0
Rule 67    updatefor -> exp0
Rule 68    whilestmt -> WHILE whilecondi stmt
Rule 69    whilecondi -> LPAREN exp0 RPAREN
Rule 70    dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
Rule 71    breakstmt -> BREAK SEMICOLON
Rule 72    contistmt -> CONTINUE SEMICOLON
Rule 73    retstmt -> RETURN SEMICOLON
Rule 74    retstmt -> RETURN exp0 SEMICOLON
Rule 75    callstmt -> ID LPAREN explist RPAREN SEMICOLON
Rule 76    blockstmt -> LBRACE stmtlist RBRACE
Rule 77    funcall -> ID LPAREN explist RPAREN
Rule 78    arraylit -> LBRACE explist RBRACE
Rule 79    explist -> empty
Rule 80    explist -> expprime
Rule 81    expprime -> exp0
Rule 82    expprime -> exp0 COMMA expprime
Rule 83    exp1 -> exp2
Rule 84    exp1 -> exp2 EQUAL exp2
Rule 85    exp1 -> exp2 NOTEQUAL exp2
Rule 86    exp1 -> exp2 LESSTHAN exp2
Rule 87    exp1 -> exp2 LEQ exp2
Rule 88    exp1 -> exp2 GREATERTHAN exp2
Rule 89    exp1 -> exp2 GEQ exp2
Rule 90    exp1 -> exp1 DOUBLECOLON exp1
Rule 91    exp0 -> exp1
Rule 92    exp2 -> exp3
Rule 93    exp2 -> exp2 AND exp3
Rule 94    exp2 -> exp2 OR exp3
Rule 95    exp4 -> exp5
Rule 96    exp4 -> exp4 MUL exp5
Rule 97    exp4 -> exp4 DIV exp5
Rule 98    exp4 -> exp4 MOD exp5
Rule 99    exp4 -> exp3 PLUS exp4
Rule 100   exp4 -> exp3 MINUS exp4
Rule 101   exp3 -> exp4
Rule 102   exp5 -> exp6
Rule 103   exp5 -> NOT exp5
Rule 104   exp6 -> exp7
Rule 105   exp6 -> MINUS exp6
Rule 106   exp7 -> exp8
Rule 107   exp7 -> ID LBRACKET expprime RBRACKET
Rule 108   exp8 -> exp9
Rule 109   exp8 -> funcall
Rule 110   exp9 -> exp10
Rule 111   exp9 -> arraylit
Rule 112   exp9 -> ID
Rule 113   exp9 -> STRINGLIT
Rule 114   exp9 -> BOOLEANLIT
Rule 115   exp9 -> FLOATLIT
Rule 116   exp9 -> INTLIT
Rule 117   exp10 -> LPAREN exp0 RPAREN
Rule 118   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 93
ARRAY                : 22
ASSIGNMENT           : 11 58 59 64
AUTO                 : 17 28
BOOLEAN              : 21
BOOLEANLIT           : 114
BREAK                : 71
COLON                : 8 9 11 29 30 36 37 38 39
COMMA                : 10 12 12 14 24 35 63 63 82
CONTINUE             : 72
DIV                  : 97
DO                   : 70
DOUBLECOLON          : 90
ELSE                 : 60 62
EQUAL                : 84
FLOAT                : 19
FLOATLIT             : 115
FOR                  : 63
FUNCTION             : 29 30
GEQ                  : 89
GREATERTHAN          : 88
ID                   : 6 7 8 10 12 13 14 29 29 30 36 37 38 39 58 59 65 75 77 107 112
IF                   : 60 61 62
INHERIT              : 29 37 39
INTEGER              : 20
INTLIT               : 23 24 116
LBRACE               : 76 78
LBRACKET             : 22 59 107
LEQ                  : 87
LESSTHAN             : 86
LPAREN               : 31 60 61 62 63 69 70 75 77 117
MINUS                : 100 105
MOD                  : 98
MUL                  : 96
NOT                  : 103
NOTEQUAL             : 85
OF                   : 22
OR                   : 94
OUT                  : 36 39
PLUS                 : 99
RBRACE               : 76 78
RBRACKET             : 22 59 107
RETURN               : 73 74
RPAREN               : 31 60 61 62 63 69 70 75 77 117
SEMICOLON            : 6 8 9 58 59 70 71 72 73 74 75
STRING               : 18
STRINGLIT            : 113
VOID                 : 27
WHILE                : 68 70
error                : 

Nonterminals, with rules where they appear:

arraylit             : 111
arrtype              : 15 25
assigstmt            : 57
atotype              : 16 22 26
blockstmt            : 29 30 48 70
breakstmt            : 52
callstmt             : 49
condifor             : 63
contistmt            : 51
decl                 : 2 3
decllist             : 1 2
dime                 : 22 24
dowhilestmt          : 53
empty                : 32 40 79
exp0                 : 6 12 58 59 60 61 62 64 66 67 69 70 74 81 82 117
exp1                 : 90 90 91
exp10                : 110
exp2                 : 83 84 84 85 85 86 86 87 87 88 88 89 89 93 94
exp3                 : 92 93 94 99 100
exp4                 : 96 97 98 99 100 101
exp5                 : 95 96 97 98 103
exp6                 : 102 105
exp7                 : 104
exp8                 : 106
exp9                 : 108
explist              : 75 77 78
expprime             : 59 80 82 107
forstmt              : 55
funcall              : 109
funcdecl             : 4
idlist               : 14
matchif              : 56
matchstmt            : 46 60 60 62
param                : 34 35
paramdecl            : 29 30
paramlist            : 31
paramprime           : 33 35
program              : 0
retstmt              : 50
returntype           : 29 30
scaladecl            : 63
scalavar             : 64
stmt                 : 42 45 61 63 68
stmtlist             : 44 45 76
stmtprime            : 41
subvardecl           : 6 7 10 12
typeof               : 8 9 11 36 37 38 39
unmatchif            : 47 62
updatefor            : 63
vardecl              : 5 43 44
whilecondi           : 68
whilestmt            : 54


state 0

    (0) S' -> . program
    (1) program -> . decllist
    (2) decllist -> . decl decllist
    (3) decllist -> . decl
    (4) decl -> . funcdecl
    (5) decl -> . vardecl
    (29) funcdecl -> . ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> . ID COLON FUNCTION returntype paramdecl blockstmt
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl
    (8) vardecl -> . ID COLON typeof SEMICOLON
    ID              shift and go to state 6

    program                        shift and go to state 1
    decllist                       shift and go to state 2
    decl                           shift and go to state 3
    funcdecl                       shift and go to state 4
    vardecl                        shift and go to state 5

state 1

    (0) S' -> program .


state 2

    (1) program -> decllist .
    $end            reduce using rule 1 (program -> decllist .)


state 3

    (2) decllist -> decl . decllist
    (3) decllist -> decl .
    (2) decllist -> . decl decllist
    (3) decllist -> . decl
    (4) decl -> . funcdecl
    (5) decl -> . vardecl
    (29) funcdecl -> . ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> . ID COLON FUNCTION returntype paramdecl blockstmt
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl
    (8) vardecl -> . ID COLON typeof SEMICOLON
    $end            reduce using rule 3 (decllist -> decl .)
    ID              shift and go to state 6

    decl                           shift and go to state 3
    decllist                       shift and go to state 7
    funcdecl                       shift and go to state 4
    vardecl                        shift and go to state 5

state 4

    (4) decl -> funcdecl .
    ID              reduce using rule 4 (decl -> funcdecl .)
    $end            reduce using rule 4 (decl -> funcdecl .)


state 5

    (5) decl -> vardecl .
    ID              reduce using rule 5 (decl -> vardecl .)
    $end            reduce using rule 5 (decl -> vardecl .)


state 6

    (29) funcdecl -> ID . COLON FUNCTION returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> ID . COLON FUNCTION returntype paramdecl blockstmt
    (6) vardecl -> ID . subvardecl exp0 SEMICOLON
    (7) vardecl -> ID . subvardecl
    (8) vardecl -> ID . COLON typeof SEMICOLON
    (9) subvardecl -> . COLON typeof SEMICOLON
    (10) subvardecl -> . COMMA ID subvardecl
    (11) subvardecl -> . COLON typeof ASSIGNMENT
    (12) subvardecl -> . COMMA ID subvardecl exp0 COMMA
    COLON           shift and go to state 8
    COMMA           shift and go to state 10

    subvardecl                     shift and go to state 9

state 7

    (2) decllist -> decl decllist .
    $end            reduce using rule 2 (decllist -> decl decllist .)


state 8

    (29) funcdecl -> ID COLON . FUNCTION returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> ID COLON . FUNCTION returntype paramdecl blockstmt
    (8) vardecl -> ID COLON . typeof SEMICOLON
    (9) subvardecl -> COLON . typeof SEMICOLON
    (11) subvardecl -> COLON . typeof ASSIGNMENT
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    FUNCTION        shift and go to state 11
    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19
    BOOLEAN         shift and go to state 20

    typeof                         shift and go to state 12
    arrtype                        shift and go to state 13
    atotype                        shift and go to state 14

state 9

    (6) vardecl -> ID subvardecl . exp0 SEMICOLON
    (7) vardecl -> ID subvardecl .
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    $end            reduce using rule 7 (vardecl -> ID subvardecl .)
    IF              reduce using rule 7 (vardecl -> ID subvardecl .)
    RETURN          reduce using rule 7 (vardecl -> ID subvardecl .)
    CONTINUE        reduce using rule 7 (vardecl -> ID subvardecl .)
    BREAK           reduce using rule 7 (vardecl -> ID subvardecl .)
    DO              reduce using rule 7 (vardecl -> ID subvardecl .)
    WHILE           reduce using rule 7 (vardecl -> ID subvardecl .)
    FOR             reduce using rule 7 (vardecl -> ID subvardecl .)
    RBRACE          reduce using rule 7 (vardecl -> ID subvardecl .)
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 22
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 10

    (10) subvardecl -> COMMA . ID subvardecl
    (12) subvardecl -> COMMA . ID subvardecl exp0 COMMA
    ID              shift and go to state 43


state 11

    (29) funcdecl -> ID COLON FUNCTION . returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> ID COLON FUNCTION . returntype paramdecl blockstmt
    (25) returntype -> . arrtype
    (26) returntype -> . atotype
    (27) returntype -> . VOID
    (28) returntype -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    VOID            shift and go to state 47
    AUTO            shift and go to state 48
    ARRAY           shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19
    BOOLEAN         shift and go to state 20

    returntype                     shift and go to state 44
    arrtype                        shift and go to state 45
    atotype                        shift and go to state 46

state 12

    (8) vardecl -> ID COLON typeof . SEMICOLON
    (9) subvardecl -> COLON typeof . SEMICOLON
    (11) subvardecl -> COLON typeof . ASSIGNMENT
    SEMICOLON       shift and go to state 49
    ASSIGNMENT      shift and go to state 50


state 13

    (15) typeof -> arrtype .
    SEMICOLON       reduce using rule 15 (typeof -> arrtype .)
    ASSIGNMENT      reduce using rule 15 (typeof -> arrtype .)
    COMMA           reduce using rule 15 (typeof -> arrtype .)
    RPAREN          reduce using rule 15 (typeof -> arrtype .)


state 14

    (16) typeof -> atotype .
    SEMICOLON       reduce using rule 16 (typeof -> atotype .)
    ASSIGNMENT      reduce using rule 16 (typeof -> atotype .)
    COMMA           reduce using rule 16 (typeof -> atotype .)
    RPAREN          reduce using rule 16 (typeof -> atotype .)


state 15

    (17) typeof -> AUTO .
    SEMICOLON       reduce using rule 17 (typeof -> AUTO .)
    ASSIGNMENT      reduce using rule 17 (typeof -> AUTO .)
    COMMA           reduce using rule 17 (typeof -> AUTO .)
    RPAREN          reduce using rule 17 (typeof -> AUTO .)


state 16

    (22) arrtype -> ARRAY . LBRACKET dime RBRACKET OF atotype
    LBRACKET        shift and go to state 51


state 17

    (18) atotype -> STRING .
    SEMICOLON       reduce using rule 18 (atotype -> STRING .)
    ASSIGNMENT      reduce using rule 18 (atotype -> STRING .)
    LPAREN          reduce using rule 18 (atotype -> STRING .)
    COMMA           reduce using rule 18 (atotype -> STRING .)
    RPAREN          reduce using rule 18 (atotype -> STRING .)


state 18

    (19) atotype -> FLOAT .
    SEMICOLON       reduce using rule 19 (atotype -> FLOAT .)
    ASSIGNMENT      reduce using rule 19 (atotype -> FLOAT .)
    LPAREN          reduce using rule 19 (atotype -> FLOAT .)
    COMMA           reduce using rule 19 (atotype -> FLOAT .)
    RPAREN          reduce using rule 19 (atotype -> FLOAT .)


state 19

    (20) atotype -> INTEGER .
    SEMICOLON       reduce using rule 20 (atotype -> INTEGER .)
    ASSIGNMENT      reduce using rule 20 (atotype -> INTEGER .)
    LPAREN          reduce using rule 20 (atotype -> INTEGER .)
    COMMA           reduce using rule 20 (atotype -> INTEGER .)
    RPAREN          reduce using rule 20 (atotype -> INTEGER .)


state 20

    (21) atotype -> BOOLEAN .
    SEMICOLON       reduce using rule 21 (atotype -> BOOLEAN .)
    ASSIGNMENT      reduce using rule 21 (atotype -> BOOLEAN .)
    LPAREN          reduce using rule 21 (atotype -> BOOLEAN .)
    COMMA           reduce using rule 21 (atotype -> BOOLEAN .)
    RPAREN          reduce using rule 21 (atotype -> BOOLEAN .)


state 21

    (107) exp7 -> ID . LBRACKET expprime RBRACKET
    (112) exp9 -> ID .
    (77) funcall -> ID . LPAREN explist RPAREN
    LBRACKET        shift and go to state 52
    MUL             reduce using rule 112 (exp9 -> ID .)
    DIV             reduce using rule 112 (exp9 -> ID .)
    MOD             reduce using rule 112 (exp9 -> ID .)
    PLUS            reduce using rule 112 (exp9 -> ID .)
    MINUS           reduce using rule 112 (exp9 -> ID .)
    EQUAL           reduce using rule 112 (exp9 -> ID .)
    NOTEQUAL        reduce using rule 112 (exp9 -> ID .)
    LESSTHAN        reduce using rule 112 (exp9 -> ID .)
    LEQ             reduce using rule 112 (exp9 -> ID .)
    GREATERTHAN     reduce using rule 112 (exp9 -> ID .)
    GEQ             reduce using rule 112 (exp9 -> ID .)
    AND             reduce using rule 112 (exp9 -> ID .)
    OR              reduce using rule 112 (exp9 -> ID .)
    DOUBLECOLON     reduce using rule 112 (exp9 -> ID .)
    SEMICOLON       reduce using rule 112 (exp9 -> ID .)
    RPAREN          reduce using rule 112 (exp9 -> ID .)
    COMMA           reduce using rule 112 (exp9 -> ID .)
    RBRACE          reduce using rule 112 (exp9 -> ID .)
    RBRACKET        reduce using rule 112 (exp9 -> ID .)
    LPAREN          shift and go to state 53


state 22

    (6) vardecl -> ID subvardecl exp0 . SEMICOLON
    SEMICOLON       shift and go to state 54


state 23

    (91) exp0 -> exp1 .
    (90) exp1 -> exp1 . DOUBLECOLON exp1
    SEMICOLON       reduce using rule 91 (exp0 -> exp1 .)
    RPAREN          reduce using rule 91 (exp0 -> exp1 .)
    COMMA           reduce using rule 91 (exp0 -> exp1 .)
    RBRACE          reduce using rule 91 (exp0 -> exp1 .)
    RBRACKET        reduce using rule 91 (exp0 -> exp1 .)
    DOUBLECOLON     shift and go to state 55


state 24

    (83) exp1 -> exp2 .
    (84) exp1 -> exp2 . EQUAL exp2
    (85) exp1 -> exp2 . NOTEQUAL exp2
    (86) exp1 -> exp2 . LESSTHAN exp2
    (87) exp1 -> exp2 . LEQ exp2
    (88) exp1 -> exp2 . GREATERTHAN exp2
    (89) exp1 -> exp2 . GEQ exp2
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 83 (exp1 -> exp2 .)
    SEMICOLON       reduce using rule 83 (exp1 -> exp2 .)
    RPAREN          reduce using rule 83 (exp1 -> exp2 .)
    COMMA           reduce using rule 83 (exp1 -> exp2 .)
    RBRACE          reduce using rule 83 (exp1 -> exp2 .)
    RBRACKET        reduce using rule 83 (exp1 -> exp2 .)
    EQUAL           shift and go to state 56
    NOTEQUAL        shift and go to state 57
    LESSTHAN        shift and go to state 58
    LEQ             shift and go to state 59
    GREATERTHAN     shift and go to state 60
    GEQ             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 25

    (92) exp2 -> exp3 .
    (99) exp4 -> exp3 . PLUS exp4
    (100) exp4 -> exp3 . MINUS exp4
    EQUAL           reduce using rule 92 (exp2 -> exp3 .)
    NOTEQUAL        reduce using rule 92 (exp2 -> exp3 .)
    LESSTHAN        reduce using rule 92 (exp2 -> exp3 .)
    LEQ             reduce using rule 92 (exp2 -> exp3 .)
    GREATERTHAN     reduce using rule 92 (exp2 -> exp3 .)
    GEQ             reduce using rule 92 (exp2 -> exp3 .)
    AND             reduce using rule 92 (exp2 -> exp3 .)
    OR              reduce using rule 92 (exp2 -> exp3 .)
    DOUBLECOLON     reduce using rule 92 (exp2 -> exp3 .)
    SEMICOLON       reduce using rule 92 (exp2 -> exp3 .)
    RPAREN          reduce using rule 92 (exp2 -> exp3 .)
    COMMA           reduce using rule 92 (exp2 -> exp3 .)
    RBRACE          reduce using rule 92 (exp2 -> exp3 .)
    RBRACKET        reduce using rule 92 (exp2 -> exp3 .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65


state 26

    (101) exp3 -> exp4 .
    (96) exp4 -> exp4 . MUL exp5
    (97) exp4 -> exp4 . DIV exp5
    (98) exp4 -> exp4 . MOD exp5
    PLUS            reduce using rule 101 (exp3 -> exp4 .)
    MINUS           reduce using rule 101 (exp3 -> exp4 .)
    EQUAL           reduce using rule 101 (exp3 -> exp4 .)
    NOTEQUAL        reduce using rule 101 (exp3 -> exp4 .)
    LESSTHAN        reduce using rule 101 (exp3 -> exp4 .)
    LEQ             reduce using rule 101 (exp3 -> exp4 .)
    GREATERTHAN     reduce using rule 101 (exp3 -> exp4 .)
    GEQ             reduce using rule 101 (exp3 -> exp4 .)
    AND             reduce using rule 101 (exp3 -> exp4 .)
    OR              reduce using rule 101 (exp3 -> exp4 .)
    DOUBLECOLON     reduce using rule 101 (exp3 -> exp4 .)
    SEMICOLON       reduce using rule 101 (exp3 -> exp4 .)
    RPAREN          reduce using rule 101 (exp3 -> exp4 .)
    COMMA           reduce using rule 101 (exp3 -> exp4 .)
    RBRACE          reduce using rule 101 (exp3 -> exp4 .)
    RBRACKET        reduce using rule 101 (exp3 -> exp4 .)
    MUL             shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68


state 27

    (95) exp4 -> exp5 .
    MUL             reduce using rule 95 (exp4 -> exp5 .)
    DIV             reduce using rule 95 (exp4 -> exp5 .)
    MOD             reduce using rule 95 (exp4 -> exp5 .)
    PLUS            reduce using rule 95 (exp4 -> exp5 .)
    MINUS           reduce using rule 95 (exp4 -> exp5 .)
    EQUAL           reduce using rule 95 (exp4 -> exp5 .)
    NOTEQUAL        reduce using rule 95 (exp4 -> exp5 .)
    LESSTHAN        reduce using rule 95 (exp4 -> exp5 .)
    LEQ             reduce using rule 95 (exp4 -> exp5 .)
    GREATERTHAN     reduce using rule 95 (exp4 -> exp5 .)
    GEQ             reduce using rule 95 (exp4 -> exp5 .)
    AND             reduce using rule 95 (exp4 -> exp5 .)
    OR              reduce using rule 95 (exp4 -> exp5 .)
    DOUBLECOLON     reduce using rule 95 (exp4 -> exp5 .)
    SEMICOLON       reduce using rule 95 (exp4 -> exp5 .)
    RPAREN          reduce using rule 95 (exp4 -> exp5 .)
    COMMA           reduce using rule 95 (exp4 -> exp5 .)
    RBRACE          reduce using rule 95 (exp4 -> exp5 .)
    RBRACKET        reduce using rule 95 (exp4 -> exp5 .)


state 28

    (105) exp6 -> MINUS . exp6
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp6                           shift and go to state 69
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 29

    (102) exp5 -> exp6 .
    MUL             reduce using rule 102 (exp5 -> exp6 .)
    DIV             reduce using rule 102 (exp5 -> exp6 .)
    MOD             reduce using rule 102 (exp5 -> exp6 .)
    PLUS            reduce using rule 102 (exp5 -> exp6 .)
    MINUS           reduce using rule 102 (exp5 -> exp6 .)
    EQUAL           reduce using rule 102 (exp5 -> exp6 .)
    NOTEQUAL        reduce using rule 102 (exp5 -> exp6 .)
    LESSTHAN        reduce using rule 102 (exp5 -> exp6 .)
    LEQ             reduce using rule 102 (exp5 -> exp6 .)
    GREATERTHAN     reduce using rule 102 (exp5 -> exp6 .)
    GEQ             reduce using rule 102 (exp5 -> exp6 .)
    AND             reduce using rule 102 (exp5 -> exp6 .)
    OR              reduce using rule 102 (exp5 -> exp6 .)
    DOUBLECOLON     reduce using rule 102 (exp5 -> exp6 .)
    SEMICOLON       reduce using rule 102 (exp5 -> exp6 .)
    RPAREN          reduce using rule 102 (exp5 -> exp6 .)
    COMMA           reduce using rule 102 (exp5 -> exp6 .)
    RBRACE          reduce using rule 102 (exp5 -> exp6 .)
    RBRACKET        reduce using rule 102 (exp5 -> exp6 .)


state 30

    (103) exp5 -> NOT . exp5
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp5                           shift and go to state 70
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 31

    (104) exp6 -> exp7 .
    MUL             reduce using rule 104 (exp6 -> exp7 .)
    DIV             reduce using rule 104 (exp6 -> exp7 .)
    MOD             reduce using rule 104 (exp6 -> exp7 .)
    PLUS            reduce using rule 104 (exp6 -> exp7 .)
    MINUS           reduce using rule 104 (exp6 -> exp7 .)
    EQUAL           reduce using rule 104 (exp6 -> exp7 .)
    NOTEQUAL        reduce using rule 104 (exp6 -> exp7 .)
    LESSTHAN        reduce using rule 104 (exp6 -> exp7 .)
    LEQ             reduce using rule 104 (exp6 -> exp7 .)
    GREATERTHAN     reduce using rule 104 (exp6 -> exp7 .)
    GEQ             reduce using rule 104 (exp6 -> exp7 .)
    AND             reduce using rule 104 (exp6 -> exp7 .)
    OR              reduce using rule 104 (exp6 -> exp7 .)
    DOUBLECOLON     reduce using rule 104 (exp6 -> exp7 .)
    SEMICOLON       reduce using rule 104 (exp6 -> exp7 .)
    RPAREN          reduce using rule 104 (exp6 -> exp7 .)
    COMMA           reduce using rule 104 (exp6 -> exp7 .)
    RBRACE          reduce using rule 104 (exp6 -> exp7 .)
    RBRACKET        reduce using rule 104 (exp6 -> exp7 .)


state 32

    (106) exp7 -> exp8 .
    MUL             reduce using rule 106 (exp7 -> exp8 .)
    DIV             reduce using rule 106 (exp7 -> exp8 .)
    MOD             reduce using rule 106 (exp7 -> exp8 .)
    PLUS            reduce using rule 106 (exp7 -> exp8 .)
    MINUS           reduce using rule 106 (exp7 -> exp8 .)
    EQUAL           reduce using rule 106 (exp7 -> exp8 .)
    NOTEQUAL        reduce using rule 106 (exp7 -> exp8 .)
    LESSTHAN        reduce using rule 106 (exp7 -> exp8 .)
    LEQ             reduce using rule 106 (exp7 -> exp8 .)
    GREATERTHAN     reduce using rule 106 (exp7 -> exp8 .)
    GEQ             reduce using rule 106 (exp7 -> exp8 .)
    AND             reduce using rule 106 (exp7 -> exp8 .)
    OR              reduce using rule 106 (exp7 -> exp8 .)
    DOUBLECOLON     reduce using rule 106 (exp7 -> exp8 .)
    SEMICOLON       reduce using rule 106 (exp7 -> exp8 .)
    RPAREN          reduce using rule 106 (exp7 -> exp8 .)
    COMMA           reduce using rule 106 (exp7 -> exp8 .)
    RBRACE          reduce using rule 106 (exp7 -> exp8 .)
    RBRACKET        reduce using rule 106 (exp7 -> exp8 .)


state 33

    (108) exp8 -> exp9 .
    MUL             reduce using rule 108 (exp8 -> exp9 .)
    DIV             reduce using rule 108 (exp8 -> exp9 .)
    MOD             reduce using rule 108 (exp8 -> exp9 .)
    PLUS            reduce using rule 108 (exp8 -> exp9 .)
    MINUS           reduce using rule 108 (exp8 -> exp9 .)
    EQUAL           reduce using rule 108 (exp8 -> exp9 .)
    NOTEQUAL        reduce using rule 108 (exp8 -> exp9 .)
    LESSTHAN        reduce using rule 108 (exp8 -> exp9 .)
    LEQ             reduce using rule 108 (exp8 -> exp9 .)
    GREATERTHAN     reduce using rule 108 (exp8 -> exp9 .)
    GEQ             reduce using rule 108 (exp8 -> exp9 .)
    AND             reduce using rule 108 (exp8 -> exp9 .)
    OR              reduce using rule 108 (exp8 -> exp9 .)
    DOUBLECOLON     reduce using rule 108 (exp8 -> exp9 .)
    SEMICOLON       reduce using rule 108 (exp8 -> exp9 .)
    RPAREN          reduce using rule 108 (exp8 -> exp9 .)
    COMMA           reduce using rule 108 (exp8 -> exp9 .)
    RBRACE          reduce using rule 108 (exp8 -> exp9 .)
    RBRACKET        reduce using rule 108 (exp8 -> exp9 .)


state 34

    (109) exp8 -> funcall .
    MUL             reduce using rule 109 (exp8 -> funcall .)
    DIV             reduce using rule 109 (exp8 -> funcall .)
    MOD             reduce using rule 109 (exp8 -> funcall .)
    PLUS            reduce using rule 109 (exp8 -> funcall .)
    MINUS           reduce using rule 109 (exp8 -> funcall .)
    EQUAL           reduce using rule 109 (exp8 -> funcall .)
    NOTEQUAL        reduce using rule 109 (exp8 -> funcall .)
    LESSTHAN        reduce using rule 109 (exp8 -> funcall .)
    LEQ             reduce using rule 109 (exp8 -> funcall .)
    GREATERTHAN     reduce using rule 109 (exp8 -> funcall .)
    GEQ             reduce using rule 109 (exp8 -> funcall .)
    AND             reduce using rule 109 (exp8 -> funcall .)
    OR              reduce using rule 109 (exp8 -> funcall .)
    DOUBLECOLON     reduce using rule 109 (exp8 -> funcall .)
    SEMICOLON       reduce using rule 109 (exp8 -> funcall .)
    RPAREN          reduce using rule 109 (exp8 -> funcall .)
    COMMA           reduce using rule 109 (exp8 -> funcall .)
    RBRACE          reduce using rule 109 (exp8 -> funcall .)
    RBRACKET        reduce using rule 109 (exp8 -> funcall .)


state 35

    (110) exp9 -> exp10 .
    MUL             reduce using rule 110 (exp9 -> exp10 .)
    DIV             reduce using rule 110 (exp9 -> exp10 .)
    MOD             reduce using rule 110 (exp9 -> exp10 .)
    PLUS            reduce using rule 110 (exp9 -> exp10 .)
    MINUS           reduce using rule 110 (exp9 -> exp10 .)
    EQUAL           reduce using rule 110 (exp9 -> exp10 .)
    NOTEQUAL        reduce using rule 110 (exp9 -> exp10 .)
    LESSTHAN        reduce using rule 110 (exp9 -> exp10 .)
    LEQ             reduce using rule 110 (exp9 -> exp10 .)
    GREATERTHAN     reduce using rule 110 (exp9 -> exp10 .)
    GEQ             reduce using rule 110 (exp9 -> exp10 .)
    AND             reduce using rule 110 (exp9 -> exp10 .)
    OR              reduce using rule 110 (exp9 -> exp10 .)
    DOUBLECOLON     reduce using rule 110 (exp9 -> exp10 .)
    SEMICOLON       reduce using rule 110 (exp9 -> exp10 .)
    RPAREN          reduce using rule 110 (exp9 -> exp10 .)
    COMMA           reduce using rule 110 (exp9 -> exp10 .)
    RBRACE          reduce using rule 110 (exp9 -> exp10 .)
    RBRACKET        reduce using rule 110 (exp9 -> exp10 .)


state 36

    (111) exp9 -> arraylit .
    MUL             reduce using rule 111 (exp9 -> arraylit .)
    DIV             reduce using rule 111 (exp9 -> arraylit .)
    MOD             reduce using rule 111 (exp9 -> arraylit .)
    PLUS            reduce using rule 111 (exp9 -> arraylit .)
    MINUS           reduce using rule 111 (exp9 -> arraylit .)
    EQUAL           reduce using rule 111 (exp9 -> arraylit .)
    NOTEQUAL        reduce using rule 111 (exp9 -> arraylit .)
    LESSTHAN        reduce using rule 111 (exp9 -> arraylit .)
    LEQ             reduce using rule 111 (exp9 -> arraylit .)
    GREATERTHAN     reduce using rule 111 (exp9 -> arraylit .)
    GEQ             reduce using rule 111 (exp9 -> arraylit .)
    AND             reduce using rule 111 (exp9 -> arraylit .)
    OR              reduce using rule 111 (exp9 -> arraylit .)
    DOUBLECOLON     reduce using rule 111 (exp9 -> arraylit .)
    SEMICOLON       reduce using rule 111 (exp9 -> arraylit .)
    RPAREN          reduce using rule 111 (exp9 -> arraylit .)
    COMMA           reduce using rule 111 (exp9 -> arraylit .)
    RBRACE          reduce using rule 111 (exp9 -> arraylit .)
    RBRACKET        reduce using rule 111 (exp9 -> arraylit .)


state 37

    (113) exp9 -> STRINGLIT .
    MUL             reduce using rule 113 (exp9 -> STRINGLIT .)
    DIV             reduce using rule 113 (exp9 -> STRINGLIT .)
    MOD             reduce using rule 113 (exp9 -> STRINGLIT .)
    PLUS            reduce using rule 113 (exp9 -> STRINGLIT .)
    MINUS           reduce using rule 113 (exp9 -> STRINGLIT .)
    EQUAL           reduce using rule 113 (exp9 -> STRINGLIT .)
    NOTEQUAL        reduce using rule 113 (exp9 -> STRINGLIT .)
    LESSTHAN        reduce using rule 113 (exp9 -> STRINGLIT .)
    LEQ             reduce using rule 113 (exp9 -> STRINGLIT .)
    GREATERTHAN     reduce using rule 113 (exp9 -> STRINGLIT .)
    GEQ             reduce using rule 113 (exp9 -> STRINGLIT .)
    AND             reduce using rule 113 (exp9 -> STRINGLIT .)
    OR              reduce using rule 113 (exp9 -> STRINGLIT .)
    DOUBLECOLON     reduce using rule 113 (exp9 -> STRINGLIT .)
    SEMICOLON       reduce using rule 113 (exp9 -> STRINGLIT .)
    RPAREN          reduce using rule 113 (exp9 -> STRINGLIT .)
    COMMA           reduce using rule 113 (exp9 -> STRINGLIT .)
    RBRACE          reduce using rule 113 (exp9 -> STRINGLIT .)
    RBRACKET        reduce using rule 113 (exp9 -> STRINGLIT .)


state 38

    (114) exp9 -> BOOLEANLIT .
    MUL             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    DIV             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    MOD             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    PLUS            reduce using rule 114 (exp9 -> BOOLEANLIT .)
    MINUS           reduce using rule 114 (exp9 -> BOOLEANLIT .)
    EQUAL           reduce using rule 114 (exp9 -> BOOLEANLIT .)
    NOTEQUAL        reduce using rule 114 (exp9 -> BOOLEANLIT .)
    LESSTHAN        reduce using rule 114 (exp9 -> BOOLEANLIT .)
    LEQ             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    GREATERTHAN     reduce using rule 114 (exp9 -> BOOLEANLIT .)
    GEQ             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    AND             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    OR              reduce using rule 114 (exp9 -> BOOLEANLIT .)
    DOUBLECOLON     reduce using rule 114 (exp9 -> BOOLEANLIT .)
    SEMICOLON       reduce using rule 114 (exp9 -> BOOLEANLIT .)
    RPAREN          reduce using rule 114 (exp9 -> BOOLEANLIT .)
    COMMA           reduce using rule 114 (exp9 -> BOOLEANLIT .)
    RBRACE          reduce using rule 114 (exp9 -> BOOLEANLIT .)
    RBRACKET        reduce using rule 114 (exp9 -> BOOLEANLIT .)


state 39

    (115) exp9 -> FLOATLIT .
    MUL             reduce using rule 115 (exp9 -> FLOATLIT .)
    DIV             reduce using rule 115 (exp9 -> FLOATLIT .)
    MOD             reduce using rule 115 (exp9 -> FLOATLIT .)
    PLUS            reduce using rule 115 (exp9 -> FLOATLIT .)
    MINUS           reduce using rule 115 (exp9 -> FLOATLIT .)
    EQUAL           reduce using rule 115 (exp9 -> FLOATLIT .)
    NOTEQUAL        reduce using rule 115 (exp9 -> FLOATLIT .)
    LESSTHAN        reduce using rule 115 (exp9 -> FLOATLIT .)
    LEQ             reduce using rule 115 (exp9 -> FLOATLIT .)
    GREATERTHAN     reduce using rule 115 (exp9 -> FLOATLIT .)
    GEQ             reduce using rule 115 (exp9 -> FLOATLIT .)
    AND             reduce using rule 115 (exp9 -> FLOATLIT .)
    OR              reduce using rule 115 (exp9 -> FLOATLIT .)
    DOUBLECOLON     reduce using rule 115 (exp9 -> FLOATLIT .)
    SEMICOLON       reduce using rule 115 (exp9 -> FLOATLIT .)
    RPAREN          reduce using rule 115 (exp9 -> FLOATLIT .)
    COMMA           reduce using rule 115 (exp9 -> FLOATLIT .)
    RBRACE          reduce using rule 115 (exp9 -> FLOATLIT .)
    RBRACKET        reduce using rule 115 (exp9 -> FLOATLIT .)


state 40

    (116) exp9 -> INTLIT .
    MUL             reduce using rule 116 (exp9 -> INTLIT .)
    DIV             reduce using rule 116 (exp9 -> INTLIT .)
    MOD             reduce using rule 116 (exp9 -> INTLIT .)
    PLUS            reduce using rule 116 (exp9 -> INTLIT .)
    MINUS           reduce using rule 116 (exp9 -> INTLIT .)
    EQUAL           reduce using rule 116 (exp9 -> INTLIT .)
    NOTEQUAL        reduce using rule 116 (exp9 -> INTLIT .)
    LESSTHAN        reduce using rule 116 (exp9 -> INTLIT .)
    LEQ             reduce using rule 116 (exp9 -> INTLIT .)
    GREATERTHAN     reduce using rule 116 (exp9 -> INTLIT .)
    GEQ             reduce using rule 116 (exp9 -> INTLIT .)
    AND             reduce using rule 116 (exp9 -> INTLIT .)
    OR              reduce using rule 116 (exp9 -> INTLIT .)
    DOUBLECOLON     reduce using rule 116 (exp9 -> INTLIT .)
    SEMICOLON       reduce using rule 116 (exp9 -> INTLIT .)
    RPAREN          reduce using rule 116 (exp9 -> INTLIT .)
    COMMA           reduce using rule 116 (exp9 -> INTLIT .)
    RBRACE          reduce using rule 116 (exp9 -> INTLIT .)
    RBRACKET        reduce using rule 116 (exp9 -> INTLIT .)


state 41

    (117) exp10 -> LPAREN . exp0 RPAREN
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 71
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 42

    (78) arraylit -> LBRACE . explist RBRACE
    (79) explist -> . empty
    (80) explist -> . expprime
    (118) empty -> .
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    RBRACE          reduce using rule 118 (empty -> .)
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    explist                        shift and go to state 72
    empty                          shift and go to state 73
    expprime                       shift and go to state 74
    exp0                           shift and go to state 75
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 43

    (10) subvardecl -> COMMA ID . subvardecl
    (12) subvardecl -> COMMA ID . subvardecl exp0 COMMA
    (9) subvardecl -> . COLON typeof SEMICOLON
    (10) subvardecl -> . COMMA ID subvardecl
    (11) subvardecl -> . COLON typeof ASSIGNMENT
    (12) subvardecl -> . COMMA ID subvardecl exp0 COMMA
    COLON           shift and go to state 77
    COMMA           shift and go to state 10

    subvardecl                     shift and go to state 76

state 44

    (29) funcdecl -> ID COLON FUNCTION returntype . paramdecl INHERIT ID blockstmt
    (30) funcdecl -> ID COLON FUNCTION returntype . paramdecl blockstmt
    (31) paramdecl -> . LPAREN paramlist RPAREN
    LPAREN          shift and go to state 79

    paramdecl                      shift and go to state 78

state 45

    (25) returntype -> arrtype .
    LPAREN          reduce using rule 25 (returntype -> arrtype .)


state 46

    (26) returntype -> atotype .
    LPAREN          reduce using rule 26 (returntype -> atotype .)


state 47

    (27) returntype -> VOID .
    LPAREN          reduce using rule 27 (returntype -> VOID .)


state 48

    (28) returntype -> AUTO .
    LPAREN          reduce using rule 28 (returntype -> AUTO .)


state 49

    (8) vardecl -> ID COLON typeof SEMICOLON .
    (9) subvardecl -> COLON typeof SEMICOLON .
  ! reduce/reduce conflict for ID resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for LBRACE resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for RETURN resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for DO resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for WHILE resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
  ! reduce/reduce conflict for RBRACE resolved using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    ID              reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    $end            reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    IF              reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    LBRACE          reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    RETURN          reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    CONTINUE        reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    BREAK           reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    DO              reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    WHILE           reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    FOR             reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    RBRACE          reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    NOT             reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    MINUS           reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    STRINGLIT       reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    BOOLEANLIT      reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    FLOATLIT        reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    INTLIT          reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    LPAREN          reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)


state 50

    (11) subvardecl -> COLON typeof ASSIGNMENT .
    NOT             reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    MINUS           reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    ID              reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    STRINGLIT       reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    BOOLEANLIT      reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    FLOATLIT        reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    INTLIT          reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    LPAREN          reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    LBRACE          reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    $end            reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    IF              reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    RETURN          reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    CONTINUE        reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    BREAK           reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    DO              reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    WHILE           reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    FOR             reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)
    RBRACE          reduce using rule 11 (subvardecl -> COLON typeof ASSIGNMENT .)


state 51

    (22) arrtype -> ARRAY LBRACKET . dime RBRACKET OF atotype
    (23) dime -> . INTLIT
    (24) dime -> . INTLIT COMMA dime
    INTLIT          shift and go to state 81

    dime                           shift and go to state 80

state 52

    (107) exp7 -> ID LBRACKET . expprime RBRACKET
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    expprime                       shift and go to state 82
    exp0                           shift and go to state 75
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 53

    (77) funcall -> ID LPAREN . explist RPAREN
    (79) explist -> . empty
    (80) explist -> . expprime
    (118) empty -> .
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    RPAREN          reduce using rule 118 (empty -> .)
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    explist                        shift and go to state 83
    empty                          shift and go to state 73
    expprime                       shift and go to state 74
    exp0                           shift and go to state 75
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 54

    (6) vardecl -> ID subvardecl exp0 SEMICOLON .
    ID              reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    $end            reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    IF              reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    LBRACE          reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    RETURN          reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    CONTINUE        reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    BREAK           reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    DO              reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    WHILE           reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    FOR             reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    RBRACE          reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)


state 55

    (90) exp1 -> exp1 DOUBLECOLON . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp1                           shift and go to state 84
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 56

    (84) exp1 -> exp2 EQUAL . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp2                           shift and go to state 85
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 57

    (85) exp1 -> exp2 NOTEQUAL . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp2                           shift and go to state 86
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 58

    (86) exp1 -> exp2 LESSTHAN . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp2                           shift and go to state 87
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 59

    (87) exp1 -> exp2 LEQ . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp2                           shift and go to state 88
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 60

    (88) exp1 -> exp2 GREATERTHAN . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp2                           shift and go to state 89
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 61

    (89) exp1 -> exp2 GEQ . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp2                           shift and go to state 90
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 62

    (93) exp2 -> exp2 AND . exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp3                           shift and go to state 91
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 63

    (94) exp2 -> exp2 OR . exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp3                           shift and go to state 92
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 64

    (99) exp4 -> exp3 PLUS . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (101) exp3 -> . exp4
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp3                           shift and go to state 93
    exp4                           shift and go to state 94
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 65

    (100) exp4 -> exp3 MINUS . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (101) exp3 -> . exp4
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp3                           shift and go to state 93
    exp4                           shift and go to state 95
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 66

    (96) exp4 -> exp4 MUL . exp5
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp5                           shift and go to state 96
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 67

    (97) exp4 -> exp4 DIV . exp5
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp5                           shift and go to state 97
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 68

    (98) exp4 -> exp4 MOD . exp5
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp5                           shift and go to state 98
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 69

    (105) exp6 -> MINUS exp6 .
    MUL             reduce using rule 105 (exp6 -> MINUS exp6 .)
    DIV             reduce using rule 105 (exp6 -> MINUS exp6 .)
    MOD             reduce using rule 105 (exp6 -> MINUS exp6 .)
    PLUS            reduce using rule 105 (exp6 -> MINUS exp6 .)
    MINUS           reduce using rule 105 (exp6 -> MINUS exp6 .)
    EQUAL           reduce using rule 105 (exp6 -> MINUS exp6 .)
    NOTEQUAL        reduce using rule 105 (exp6 -> MINUS exp6 .)
    LESSTHAN        reduce using rule 105 (exp6 -> MINUS exp6 .)
    LEQ             reduce using rule 105 (exp6 -> MINUS exp6 .)
    GREATERTHAN     reduce using rule 105 (exp6 -> MINUS exp6 .)
    GEQ             reduce using rule 105 (exp6 -> MINUS exp6 .)
    AND             reduce using rule 105 (exp6 -> MINUS exp6 .)
    OR              reduce using rule 105 (exp6 -> MINUS exp6 .)
    DOUBLECOLON     reduce using rule 105 (exp6 -> MINUS exp6 .)
    SEMICOLON       reduce using rule 105 (exp6 -> MINUS exp6 .)
    RPAREN          reduce using rule 105 (exp6 -> MINUS exp6 .)
    COMMA           reduce using rule 105 (exp6 -> MINUS exp6 .)
    RBRACE          reduce using rule 105 (exp6 -> MINUS exp6 .)
    RBRACKET        reduce using rule 105 (exp6 -> MINUS exp6 .)


state 70

    (103) exp5 -> NOT exp5 .
    MUL             reduce using rule 103 (exp5 -> NOT exp5 .)
    DIV             reduce using rule 103 (exp5 -> NOT exp5 .)
    MOD             reduce using rule 103 (exp5 -> NOT exp5 .)
    PLUS            reduce using rule 103 (exp5 -> NOT exp5 .)
    MINUS           reduce using rule 103 (exp5 -> NOT exp5 .)
    EQUAL           reduce using rule 103 (exp5 -> NOT exp5 .)
    NOTEQUAL        reduce using rule 103 (exp5 -> NOT exp5 .)
    LESSTHAN        reduce using rule 103 (exp5 -> NOT exp5 .)
    LEQ             reduce using rule 103 (exp5 -> NOT exp5 .)
    GREATERTHAN     reduce using rule 103 (exp5 -> NOT exp5 .)
    GEQ             reduce using rule 103 (exp5 -> NOT exp5 .)
    AND             reduce using rule 103 (exp5 -> NOT exp5 .)
    OR              reduce using rule 103 (exp5 -> NOT exp5 .)
    DOUBLECOLON     reduce using rule 103 (exp5 -> NOT exp5 .)
    SEMICOLON       reduce using rule 103 (exp5 -> NOT exp5 .)
    RPAREN          reduce using rule 103 (exp5 -> NOT exp5 .)
    COMMA           reduce using rule 103 (exp5 -> NOT exp5 .)
    RBRACE          reduce using rule 103 (exp5 -> NOT exp5 .)
    RBRACKET        reduce using rule 103 (exp5 -> NOT exp5 .)


state 71

    (117) exp10 -> LPAREN exp0 . RPAREN
    RPAREN          shift and go to state 99


state 72

    (78) arraylit -> LBRACE explist . RBRACE
    RBRACE          shift and go to state 100


state 73

    (79) explist -> empty .
    RBRACE          reduce using rule 79 (explist -> empty .)
    RPAREN          reduce using rule 79 (explist -> empty .)


state 74

    (80) explist -> expprime .
    RBRACE          reduce using rule 80 (explist -> expprime .)
    RPAREN          reduce using rule 80 (explist -> expprime .)


state 75

    (81) expprime -> exp0 .
    (82) expprime -> exp0 . COMMA expprime
    RBRACE          reduce using rule 81 (expprime -> exp0 .)
    RBRACKET        reduce using rule 81 (expprime -> exp0 .)
    RPAREN          reduce using rule 81 (expprime -> exp0 .)
    COMMA           shift and go to state 101


state 76

    (10) subvardecl -> COMMA ID subvardecl .
    (12) subvardecl -> COMMA ID subvardecl . exp0 COMMA
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRINGLIT resolved as shift
  ! shift/reduce conflict for BOOLEANLIT resolved as shift
  ! shift/reduce conflict for FLOATLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    $end            reduce using rule 10 (subvardecl -> COMMA ID subvardecl .)
    IF              reduce using rule 10 (subvardecl -> COMMA ID subvardecl .)
    RETURN          reduce using rule 10 (subvardecl -> COMMA ID subvardecl .)
    CONTINUE        reduce using rule 10 (subvardecl -> COMMA ID subvardecl .)
    BREAK           reduce using rule 10 (subvardecl -> COMMA ID subvardecl .)
    DO              reduce using rule 10 (subvardecl -> COMMA ID subvardecl .)
    WHILE           reduce using rule 10 (subvardecl -> COMMA ID subvardecl .)
    FOR             reduce using rule 10 (subvardecl -> COMMA ID subvardecl .)
    RBRACE          reduce using rule 10 (subvardecl -> COMMA ID subvardecl .)
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 102
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 77

    (9) subvardecl -> COLON . typeof SEMICOLON
    (11) subvardecl -> COLON . typeof ASSIGNMENT
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19
    BOOLEAN         shift and go to state 20

    typeof                         shift and go to state 103
    arrtype                        shift and go to state 13
    atotype                        shift and go to state 14

state 78

    (29) funcdecl -> ID COLON FUNCTION returntype paramdecl . INHERIT ID blockstmt
    (30) funcdecl -> ID COLON FUNCTION returntype paramdecl . blockstmt
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    INHERIT         shift and go to state 104
    LBRACE          shift and go to state 106

    blockstmt                      shift and go to state 105

state 79

    (31) paramdecl -> LPAREN . paramlist RPAREN
    (32) paramlist -> . empty
    (33) paramlist -> . paramprime
    (118) empty -> .
    (34) paramprime -> . param
    (35) paramprime -> . param COMMA paramprime
    (36) param -> . OUT ID COLON typeof
    (37) param -> . INHERIT ID COLON typeof
    (38) param -> . ID COLON typeof
    (39) param -> . INHERIT OUT ID COLON typeof
    RPAREN          reduce using rule 118 (empty -> .)
    OUT             shift and go to state 111
    INHERIT         shift and go to state 113
    ID              shift and go to state 112

    paramlist                      shift and go to state 107
    empty                          shift and go to state 108
    paramprime                     shift and go to state 109
    param                          shift and go to state 110

state 80

    (22) arrtype -> ARRAY LBRACKET dime . RBRACKET OF atotype
    RBRACKET        shift and go to state 114


state 81

    (23) dime -> INTLIT .
    (24) dime -> INTLIT . COMMA dime
    RBRACKET        reduce using rule 23 (dime -> INTLIT .)
    COMMA           shift and go to state 115


state 82

    (107) exp7 -> ID LBRACKET expprime . RBRACKET
    RBRACKET        shift and go to state 116


state 83

    (77) funcall -> ID LPAREN explist . RPAREN
    RPAREN          shift and go to state 117


state 84

    (90) exp1 -> exp1 DOUBLECOLON exp1 .
    (90) exp1 -> exp1 . DOUBLECOLON exp1
  ! shift/reduce conflict for DOUBLECOLON resolved as shift
    SEMICOLON       reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    RPAREN          reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    COMMA           reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    RBRACE          reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    RBRACKET        reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    DOUBLECOLON     shift and go to state 55


state 85

    (84) exp1 -> exp2 EQUAL exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    SEMICOLON       reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    RPAREN          reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    COMMA           reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    RBRACE          reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    RBRACKET        reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    AND             shift and go to state 62
    OR              shift and go to state 63


state 86

    (85) exp1 -> exp2 NOTEQUAL exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    SEMICOLON       reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    RPAREN          reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    COMMA           reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    RBRACE          reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    RBRACKET        reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    AND             shift and go to state 62
    OR              shift and go to state 63


state 87

    (86) exp1 -> exp2 LESSTHAN exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    SEMICOLON       reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    RPAREN          reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    COMMA           reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    RBRACE          reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    RBRACKET        reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    AND             shift and go to state 62
    OR              shift and go to state 63


state 88

    (87) exp1 -> exp2 LEQ exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    SEMICOLON       reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    RPAREN          reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    COMMA           reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    RBRACE          reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    RBRACKET        reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    AND             shift and go to state 62
    OR              shift and go to state 63


state 89

    (88) exp1 -> exp2 GREATERTHAN exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    SEMICOLON       reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    RPAREN          reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    COMMA           reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    RBRACE          reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    RBRACKET        reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    AND             shift and go to state 62
    OR              shift and go to state 63


state 90

    (89) exp1 -> exp2 GEQ exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    SEMICOLON       reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    RPAREN          reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    COMMA           reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    RBRACE          reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    RBRACKET        reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    AND             shift and go to state 62
    OR              shift and go to state 63


state 91

    (93) exp2 -> exp2 AND exp3 .
    (99) exp4 -> exp3 . PLUS exp4
    (100) exp4 -> exp3 . MINUS exp4
    EQUAL           reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    NOTEQUAL        reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    LESSTHAN        reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    LEQ             reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    GREATERTHAN     reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    GEQ             reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    AND             reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    OR              reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    DOUBLECOLON     reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    SEMICOLON       reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    RPAREN          reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    COMMA           reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    RBRACE          reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    RBRACKET        reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65


state 92

    (94) exp2 -> exp2 OR exp3 .
    (99) exp4 -> exp3 . PLUS exp4
    (100) exp4 -> exp3 . MINUS exp4
    EQUAL           reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    NOTEQUAL        reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    LESSTHAN        reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    LEQ             reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    GREATERTHAN     reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    GEQ             reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    AND             reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    OR              reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    DOUBLECOLON     reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    SEMICOLON       reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    RPAREN          reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    COMMA           reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    RBRACE          reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    RBRACKET        reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65


state 93

    (99) exp4 -> exp3 . PLUS exp4
    (100) exp4 -> exp3 . MINUS exp4
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65


state 94

    (99) exp4 -> exp3 PLUS exp4 .
    (96) exp4 -> exp4 . MUL exp5
    (97) exp4 -> exp4 . DIV exp5
    (98) exp4 -> exp4 . MOD exp5
    (101) exp3 -> exp4 .
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 99 (exp4 -> exp3 PLUS exp4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 99 (exp4 -> exp3 PLUS exp4 .)
    PLUS            reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    MINUS           reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    EQUAL           reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    NOTEQUAL        reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    LESSTHAN        reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    LEQ             reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    GREATERTHAN     reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    GEQ             reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    AND             reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    OR              reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    DOUBLECOLON     reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    SEMICOLON       reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    RPAREN          reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    COMMA           reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    RBRACE          reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    RBRACKET        reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    MUL             shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68


state 95

    (100) exp4 -> exp3 MINUS exp4 .
    (96) exp4 -> exp4 . MUL exp5
    (97) exp4 -> exp4 . DIV exp5
    (98) exp4 -> exp4 . MOD exp5
    (101) exp3 -> exp4 .
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 100 (exp4 -> exp3 MINUS exp4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 100 (exp4 -> exp3 MINUS exp4 .)
    PLUS            reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    MINUS           reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    EQUAL           reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    NOTEQUAL        reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    LESSTHAN        reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    LEQ             reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    GREATERTHAN     reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    GEQ             reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    AND             reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    OR              reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    DOUBLECOLON     reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    SEMICOLON       reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    RPAREN          reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    COMMA           reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    RBRACE          reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    RBRACKET        reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    MUL             shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68


state 96

    (96) exp4 -> exp4 MUL exp5 .
    MUL             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    DIV             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    MOD             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    PLUS            reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    MINUS           reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    EQUAL           reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    NOTEQUAL        reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    LESSTHAN        reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    LEQ             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    GREATERTHAN     reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    GEQ             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    AND             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    OR              reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    DOUBLECOLON     reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    SEMICOLON       reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    RPAREN          reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    COMMA           reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    RBRACE          reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    RBRACKET        reduce using rule 96 (exp4 -> exp4 MUL exp5 .)


state 97

    (97) exp4 -> exp4 DIV exp5 .
    MUL             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    DIV             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    MOD             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    PLUS            reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    MINUS           reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    EQUAL           reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    NOTEQUAL        reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    LESSTHAN        reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    LEQ             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    GREATERTHAN     reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    GEQ             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    AND             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    OR              reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    DOUBLECOLON     reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    SEMICOLON       reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    RPAREN          reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    COMMA           reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    RBRACE          reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    RBRACKET        reduce using rule 97 (exp4 -> exp4 DIV exp5 .)


state 98

    (98) exp4 -> exp4 MOD exp5 .
    MUL             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    DIV             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    MOD             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    PLUS            reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    MINUS           reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    EQUAL           reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    NOTEQUAL        reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    LESSTHAN        reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    LEQ             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    GREATERTHAN     reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    GEQ             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    AND             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    OR              reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    DOUBLECOLON     reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    SEMICOLON       reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    RPAREN          reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    COMMA           reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    RBRACE          reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    RBRACKET        reduce using rule 98 (exp4 -> exp4 MOD exp5 .)


state 99

    (117) exp10 -> LPAREN exp0 RPAREN .
    MUL             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    DIV             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    MOD             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    PLUS            reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    MINUS           reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    EQUAL           reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    NOTEQUAL        reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    LESSTHAN        reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    LEQ             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    GREATERTHAN     reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    GEQ             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    AND             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    OR              reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    DOUBLECOLON     reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    SEMICOLON       reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    RPAREN          reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    COMMA           reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    RBRACE          reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    RBRACKET        reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)


state 100

    (78) arraylit -> LBRACE explist RBRACE .
    MUL             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    DIV             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    MOD             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    PLUS            reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    MINUS           reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    EQUAL           reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    NOTEQUAL        reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    LESSTHAN        reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    LEQ             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    GREATERTHAN     reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    GEQ             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    AND             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    OR              reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    DOUBLECOLON     reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    SEMICOLON       reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    RPAREN          reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    COMMA           reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    RBRACE          reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    RBRACKET        reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)


state 101

    (82) expprime -> exp0 COMMA . expprime
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 75
    expprime                       shift and go to state 118
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 102

    (12) subvardecl -> COMMA ID subvardecl exp0 . COMMA
    COMMA           shift and go to state 119


state 103

    (9) subvardecl -> COLON typeof . SEMICOLON
    (11) subvardecl -> COLON typeof . ASSIGNMENT
    SEMICOLON       shift and go to state 120
    ASSIGNMENT      shift and go to state 50


state 104

    (29) funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT . ID blockstmt
    ID              shift and go to state 121


state 105

    (30) funcdecl -> ID COLON FUNCTION returntype paramdecl blockstmt .
    ID              reduce using rule 30 (funcdecl -> ID COLON FUNCTION returntype paramdecl blockstmt .)
    $end            reduce using rule 30 (funcdecl -> ID COLON FUNCTION returntype paramdecl blockstmt .)


state 106

    (76) blockstmt -> LBRACE . stmtlist RBRACE
    (40) stmtlist -> . empty
    (41) stmtlist -> . stmtprime
    (118) empty -> .
    (42) stmtprime -> . stmt
    (43) stmtprime -> . vardecl
    (44) stmtprime -> . vardecl stmtlist
    (45) stmtprime -> . stmt stmtlist
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl
    (8) vardecl -> . ID COLON typeof SEMICOLON
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    RBRACE          reduce using rule 118 (empty -> .)
    ID              shift and go to state 129
    IF              shift and go to state 140
    LBRACE          shift and go to state 106
    RETURN          shift and go to state 141
    CONTINUE        shift and go to state 142
    BREAK           shift and go to state 143
    DO              shift and go to state 144
    WHILE           shift and go to state 145
    FOR             shift and go to state 146

    stmtlist                       shift and go to state 122
    empty                          shift and go to state 123
    stmtprime                      shift and go to state 124
    stmt                           shift and go to state 125
    vardecl                        shift and go to state 126
    matchstmt                      shift and go to state 127
    unmatchif                      shift and go to state 128
    blockstmt                      shift and go to state 130
    callstmt                       shift and go to state 131
    retstmt                        shift and go to state 132
    contistmt                      shift and go to state 133
    breakstmt                      shift and go to state 134
    dowhilestmt                    shift and go to state 135
    whilestmt                      shift and go to state 136
    forstmt                        shift and go to state 137
    matchif                        shift and go to state 138
    assigstmt                      shift and go to state 139

state 107

    (31) paramdecl -> LPAREN paramlist . RPAREN
    RPAREN          shift and go to state 147


state 108

    (32) paramlist -> empty .
    RPAREN          reduce using rule 32 (paramlist -> empty .)


state 109

    (33) paramlist -> paramprime .
    RPAREN          reduce using rule 33 (paramlist -> paramprime .)


state 110

    (34) paramprime -> param .
    (35) paramprime -> param . COMMA paramprime
    RPAREN          reduce using rule 34 (paramprime -> param .)
    COMMA           shift and go to state 148


state 111

    (36) param -> OUT . ID COLON typeof
    ID              shift and go to state 149


state 112

    (38) param -> ID . COLON typeof
    COLON           shift and go to state 150


state 113

    (37) param -> INHERIT . ID COLON typeof
    (39) param -> INHERIT . OUT ID COLON typeof
    ID              shift and go to state 151
    OUT             shift and go to state 152


state 114

    (22) arrtype -> ARRAY LBRACKET dime RBRACKET . OF atotype
    OF              shift and go to state 153


state 115

    (24) dime -> INTLIT COMMA . dime
    (23) dime -> . INTLIT
    (24) dime -> . INTLIT COMMA dime
    INTLIT          shift and go to state 81

    dime                           shift and go to state 154

state 116

    (107) exp7 -> ID LBRACKET expprime RBRACKET .
    MUL             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    DIV             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    MOD             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    PLUS            reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    MINUS           reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    EQUAL           reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    NOTEQUAL        reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    LESSTHAN        reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    LEQ             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    GREATERTHAN     reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    GEQ             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    AND             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    OR              reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    DOUBLECOLON     reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    SEMICOLON       reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    RPAREN          reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    COMMA           reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    RBRACE          reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    RBRACKET        reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)


state 117

    (77) funcall -> ID LPAREN explist RPAREN .
    MUL             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    DIV             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    MOD             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    PLUS            reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    MINUS           reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    EQUAL           reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    NOTEQUAL        reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    LESSTHAN        reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    LEQ             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    GREATERTHAN     reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    GEQ             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    AND             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    OR              reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    DOUBLECOLON     reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    SEMICOLON       reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    RPAREN          reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    COMMA           reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    RBRACE          reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    RBRACKET        reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)


state 118

    (82) expprime -> exp0 COMMA expprime .
    RBRACE          reduce using rule 82 (expprime -> exp0 COMMA expprime .)
    RBRACKET        reduce using rule 82 (expprime -> exp0 COMMA expprime .)
    RPAREN          reduce using rule 82 (expprime -> exp0 COMMA expprime .)


state 119

    (12) subvardecl -> COMMA ID subvardecl exp0 COMMA .
    NOT             reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    MINUS           reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    ID              reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    STRINGLIT       reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    BOOLEANLIT      reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    FLOATLIT        reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    INTLIT          reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    LPAREN          reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    LBRACE          reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    $end            reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    IF              reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    RETURN          reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    CONTINUE        reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    BREAK           reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    DO              reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    WHILE           reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    FOR             reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    RBRACE          reduce using rule 12 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)


state 120

    (9) subvardecl -> COLON typeof SEMICOLON .
    NOT             reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    MINUS           reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    ID              reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    STRINGLIT       reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    BOOLEANLIT      reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    FLOATLIT        reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    INTLIT          reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    LPAREN          reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    LBRACE          reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    $end            reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    IF              reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    RETURN          reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    CONTINUE        reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    BREAK           reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    DO              reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    WHILE           reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    FOR             reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)
    RBRACE          reduce using rule 9 (subvardecl -> COLON typeof SEMICOLON .)


state 121

    (29) funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID . blockstmt
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    LBRACE          shift and go to state 106

    blockstmt                      shift and go to state 155

state 122

    (76) blockstmt -> LBRACE stmtlist . RBRACE
    RBRACE          shift and go to state 156


state 123

    (40) stmtlist -> empty .
    RBRACE          reduce using rule 40 (stmtlist -> empty .)


state 124

    (41) stmtlist -> stmtprime .
    RBRACE          reduce using rule 41 (stmtlist -> stmtprime .)


state 125

    (42) stmtprime -> stmt .
    (45) stmtprime -> stmt . stmtlist
    (40) stmtlist -> . empty
    (41) stmtlist -> . stmtprime
    (118) empty -> .
    (42) stmtprime -> . stmt
    (43) stmtprime -> . vardecl
    (44) stmtprime -> . vardecl stmtlist
    (45) stmtprime -> . stmt stmtlist
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl
    (8) vardecl -> . ID COLON typeof SEMICOLON
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
  ! reduce/reduce conflict for RBRACE resolved using rule 42 (stmtprime -> stmt .)
    RBRACE          reduce using rule 42 (stmtprime -> stmt .)
    ID              shift and go to state 129
    IF              shift and go to state 140
    LBRACE          shift and go to state 106
    RETURN          shift and go to state 141
    CONTINUE        shift and go to state 142
    BREAK           shift and go to state 143
    DO              shift and go to state 144
    WHILE           shift and go to state 145
    FOR             shift and go to state 146

    stmt                           shift and go to state 125
    stmtlist                       shift and go to state 157
    empty                          shift and go to state 123
    stmtprime                      shift and go to state 124
    vardecl                        shift and go to state 126
    matchstmt                      shift and go to state 127
    unmatchif                      shift and go to state 128
    blockstmt                      shift and go to state 130
    callstmt                       shift and go to state 131
    retstmt                        shift and go to state 132
    contistmt                      shift and go to state 133
    breakstmt                      shift and go to state 134
    dowhilestmt                    shift and go to state 135
    whilestmt                      shift and go to state 136
    forstmt                        shift and go to state 137
    matchif                        shift and go to state 138
    assigstmt                      shift and go to state 139

state 126

    (43) stmtprime -> vardecl .
    (44) stmtprime -> vardecl . stmtlist
    (40) stmtlist -> . empty
    (41) stmtlist -> . stmtprime
    (118) empty -> .
    (42) stmtprime -> . stmt
    (43) stmtprime -> . vardecl
    (44) stmtprime -> . vardecl stmtlist
    (45) stmtprime -> . stmt stmtlist
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl
    (8) vardecl -> . ID COLON typeof SEMICOLON
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
  ! reduce/reduce conflict for RBRACE resolved using rule 43 (stmtprime -> vardecl .)
    RBRACE          reduce using rule 43 (stmtprime -> vardecl .)
    ID              shift and go to state 129
    IF              shift and go to state 140
    LBRACE          shift and go to state 106
    RETURN          shift and go to state 141
    CONTINUE        shift and go to state 142
    BREAK           shift and go to state 143
    DO              shift and go to state 144
    WHILE           shift and go to state 145
    FOR             shift and go to state 146

    vardecl                        shift and go to state 126
    stmtlist                       shift and go to state 158
    empty                          shift and go to state 123
    stmtprime                      shift and go to state 124
    stmt                           shift and go to state 125
    matchstmt                      shift and go to state 127
    unmatchif                      shift and go to state 128
    blockstmt                      shift and go to state 130
    callstmt                       shift and go to state 131
    retstmt                        shift and go to state 132
    contistmt                      shift and go to state 133
    breakstmt                      shift and go to state 134
    dowhilestmt                    shift and go to state 135
    whilestmt                      shift and go to state 136
    forstmt                        shift and go to state 137
    matchif                        shift and go to state 138
    assigstmt                      shift and go to state 139

state 127

    (46) stmt -> matchstmt .
    ID              reduce using rule 46 (stmt -> matchstmt .)
    IF              reduce using rule 46 (stmt -> matchstmt .)
    LBRACE          reduce using rule 46 (stmt -> matchstmt .)
    RETURN          reduce using rule 46 (stmt -> matchstmt .)
    CONTINUE        reduce using rule 46 (stmt -> matchstmt .)
    BREAK           reduce using rule 46 (stmt -> matchstmt .)
    DO              reduce using rule 46 (stmt -> matchstmt .)
    WHILE           reduce using rule 46 (stmt -> matchstmt .)
    FOR             reduce using rule 46 (stmt -> matchstmt .)
    RBRACE          reduce using rule 46 (stmt -> matchstmt .)
    ELSE            reduce using rule 46 (stmt -> matchstmt .)


state 128

    (47) stmt -> unmatchif .
    ID              reduce using rule 47 (stmt -> unmatchif .)
    IF              reduce using rule 47 (stmt -> unmatchif .)
    LBRACE          reduce using rule 47 (stmt -> unmatchif .)
    RETURN          reduce using rule 47 (stmt -> unmatchif .)
    CONTINUE        reduce using rule 47 (stmt -> unmatchif .)
    BREAK           reduce using rule 47 (stmt -> unmatchif .)
    DO              reduce using rule 47 (stmt -> unmatchif .)
    WHILE           reduce using rule 47 (stmt -> unmatchif .)
    FOR             reduce using rule 47 (stmt -> unmatchif .)
    RBRACE          reduce using rule 47 (stmt -> unmatchif .)
    ELSE            reduce using rule 47 (stmt -> unmatchif .)


state 129

    (6) vardecl -> ID . subvardecl exp0 SEMICOLON
    (7) vardecl -> ID . subvardecl
    (8) vardecl -> ID . COLON typeof SEMICOLON
    (75) callstmt -> ID . LPAREN explist RPAREN SEMICOLON
    (58) assigstmt -> ID . ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> ID . LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    (9) subvardecl -> . COLON typeof SEMICOLON
    (10) subvardecl -> . COMMA ID subvardecl
    (11) subvardecl -> . COLON typeof ASSIGNMENT
    (12) subvardecl -> . COMMA ID subvardecl exp0 COMMA
    COLON           shift and go to state 159
    LPAREN          shift and go to state 160
    ASSIGNMENT      shift and go to state 161
    LBRACKET        shift and go to state 162
    COMMA           shift and go to state 10

    subvardecl                     shift and go to state 9

state 130

    (48) matchstmt -> blockstmt .
    ID              reduce using rule 48 (matchstmt -> blockstmt .)
    IF              reduce using rule 48 (matchstmt -> blockstmt .)
    LBRACE          reduce using rule 48 (matchstmt -> blockstmt .)
    RETURN          reduce using rule 48 (matchstmt -> blockstmt .)
    CONTINUE        reduce using rule 48 (matchstmt -> blockstmt .)
    BREAK           reduce using rule 48 (matchstmt -> blockstmt .)
    DO              reduce using rule 48 (matchstmt -> blockstmt .)
    WHILE           reduce using rule 48 (matchstmt -> blockstmt .)
    FOR             reduce using rule 48 (matchstmt -> blockstmt .)
    RBRACE          reduce using rule 48 (matchstmt -> blockstmt .)
    ELSE            reduce using rule 48 (matchstmt -> blockstmt .)


state 131

    (49) matchstmt -> callstmt .
    ID              reduce using rule 49 (matchstmt -> callstmt .)
    IF              reduce using rule 49 (matchstmt -> callstmt .)
    LBRACE          reduce using rule 49 (matchstmt -> callstmt .)
    RETURN          reduce using rule 49 (matchstmt -> callstmt .)
    CONTINUE        reduce using rule 49 (matchstmt -> callstmt .)
    BREAK           reduce using rule 49 (matchstmt -> callstmt .)
    DO              reduce using rule 49 (matchstmt -> callstmt .)
    WHILE           reduce using rule 49 (matchstmt -> callstmt .)
    FOR             reduce using rule 49 (matchstmt -> callstmt .)
    RBRACE          reduce using rule 49 (matchstmt -> callstmt .)
    ELSE            reduce using rule 49 (matchstmt -> callstmt .)


state 132

    (50) matchstmt -> retstmt .
    ID              reduce using rule 50 (matchstmt -> retstmt .)
    IF              reduce using rule 50 (matchstmt -> retstmt .)
    LBRACE          reduce using rule 50 (matchstmt -> retstmt .)
    RETURN          reduce using rule 50 (matchstmt -> retstmt .)
    CONTINUE        reduce using rule 50 (matchstmt -> retstmt .)
    BREAK           reduce using rule 50 (matchstmt -> retstmt .)
    DO              reduce using rule 50 (matchstmt -> retstmt .)
    WHILE           reduce using rule 50 (matchstmt -> retstmt .)
    FOR             reduce using rule 50 (matchstmt -> retstmt .)
    RBRACE          reduce using rule 50 (matchstmt -> retstmt .)
    ELSE            reduce using rule 50 (matchstmt -> retstmt .)


state 133

    (51) matchstmt -> contistmt .
    ID              reduce using rule 51 (matchstmt -> contistmt .)
    IF              reduce using rule 51 (matchstmt -> contistmt .)
    LBRACE          reduce using rule 51 (matchstmt -> contistmt .)
    RETURN          reduce using rule 51 (matchstmt -> contistmt .)
    CONTINUE        reduce using rule 51 (matchstmt -> contistmt .)
    BREAK           reduce using rule 51 (matchstmt -> contistmt .)
    DO              reduce using rule 51 (matchstmt -> contistmt .)
    WHILE           reduce using rule 51 (matchstmt -> contistmt .)
    FOR             reduce using rule 51 (matchstmt -> contistmt .)
    RBRACE          reduce using rule 51 (matchstmt -> contistmt .)
    ELSE            reduce using rule 51 (matchstmt -> contistmt .)


state 134

    (52) matchstmt -> breakstmt .
    ID              reduce using rule 52 (matchstmt -> breakstmt .)
    IF              reduce using rule 52 (matchstmt -> breakstmt .)
    LBRACE          reduce using rule 52 (matchstmt -> breakstmt .)
    RETURN          reduce using rule 52 (matchstmt -> breakstmt .)
    CONTINUE        reduce using rule 52 (matchstmt -> breakstmt .)
    BREAK           reduce using rule 52 (matchstmt -> breakstmt .)
    DO              reduce using rule 52 (matchstmt -> breakstmt .)
    WHILE           reduce using rule 52 (matchstmt -> breakstmt .)
    FOR             reduce using rule 52 (matchstmt -> breakstmt .)
    RBRACE          reduce using rule 52 (matchstmt -> breakstmt .)
    ELSE            reduce using rule 52 (matchstmt -> breakstmt .)


state 135

    (53) matchstmt -> dowhilestmt .
    ID              reduce using rule 53 (matchstmt -> dowhilestmt .)
    IF              reduce using rule 53 (matchstmt -> dowhilestmt .)
    LBRACE          reduce using rule 53 (matchstmt -> dowhilestmt .)
    RETURN          reduce using rule 53 (matchstmt -> dowhilestmt .)
    CONTINUE        reduce using rule 53 (matchstmt -> dowhilestmt .)
    BREAK           reduce using rule 53 (matchstmt -> dowhilestmt .)
    DO              reduce using rule 53 (matchstmt -> dowhilestmt .)
    WHILE           reduce using rule 53 (matchstmt -> dowhilestmt .)
    FOR             reduce using rule 53 (matchstmt -> dowhilestmt .)
    RBRACE          reduce using rule 53 (matchstmt -> dowhilestmt .)
    ELSE            reduce using rule 53 (matchstmt -> dowhilestmt .)


state 136

    (54) matchstmt -> whilestmt .
    ID              reduce using rule 54 (matchstmt -> whilestmt .)
    IF              reduce using rule 54 (matchstmt -> whilestmt .)
    LBRACE          reduce using rule 54 (matchstmt -> whilestmt .)
    RETURN          reduce using rule 54 (matchstmt -> whilestmt .)
    CONTINUE        reduce using rule 54 (matchstmt -> whilestmt .)
    BREAK           reduce using rule 54 (matchstmt -> whilestmt .)
    DO              reduce using rule 54 (matchstmt -> whilestmt .)
    WHILE           reduce using rule 54 (matchstmt -> whilestmt .)
    FOR             reduce using rule 54 (matchstmt -> whilestmt .)
    RBRACE          reduce using rule 54 (matchstmt -> whilestmt .)
    ELSE            reduce using rule 54 (matchstmt -> whilestmt .)


state 137

    (55) matchstmt -> forstmt .
    ID              reduce using rule 55 (matchstmt -> forstmt .)
    IF              reduce using rule 55 (matchstmt -> forstmt .)
    LBRACE          reduce using rule 55 (matchstmt -> forstmt .)
    RETURN          reduce using rule 55 (matchstmt -> forstmt .)
    CONTINUE        reduce using rule 55 (matchstmt -> forstmt .)
    BREAK           reduce using rule 55 (matchstmt -> forstmt .)
    DO              reduce using rule 55 (matchstmt -> forstmt .)
    WHILE           reduce using rule 55 (matchstmt -> forstmt .)
    FOR             reduce using rule 55 (matchstmt -> forstmt .)
    RBRACE          reduce using rule 55 (matchstmt -> forstmt .)
    ELSE            reduce using rule 55 (matchstmt -> forstmt .)


state 138

    (56) matchstmt -> matchif .
    ID              reduce using rule 56 (matchstmt -> matchif .)
    IF              reduce using rule 56 (matchstmt -> matchif .)
    LBRACE          reduce using rule 56 (matchstmt -> matchif .)
    RETURN          reduce using rule 56 (matchstmt -> matchif .)
    CONTINUE        reduce using rule 56 (matchstmt -> matchif .)
    BREAK           reduce using rule 56 (matchstmt -> matchif .)
    DO              reduce using rule 56 (matchstmt -> matchif .)
    WHILE           reduce using rule 56 (matchstmt -> matchif .)
    FOR             reduce using rule 56 (matchstmt -> matchif .)
    RBRACE          reduce using rule 56 (matchstmt -> matchif .)
    ELSE            reduce using rule 56 (matchstmt -> matchif .)


state 139

    (57) matchstmt -> assigstmt .
    ID              reduce using rule 57 (matchstmt -> assigstmt .)
    IF              reduce using rule 57 (matchstmt -> assigstmt .)
    LBRACE          reduce using rule 57 (matchstmt -> assigstmt .)
    RETURN          reduce using rule 57 (matchstmt -> assigstmt .)
    CONTINUE        reduce using rule 57 (matchstmt -> assigstmt .)
    BREAK           reduce using rule 57 (matchstmt -> assigstmt .)
    DO              reduce using rule 57 (matchstmt -> assigstmt .)
    WHILE           reduce using rule 57 (matchstmt -> assigstmt .)
    FOR             reduce using rule 57 (matchstmt -> assigstmt .)
    RBRACE          reduce using rule 57 (matchstmt -> assigstmt .)
    ELSE            reduce using rule 57 (matchstmt -> assigstmt .)


state 140

    (61) unmatchif -> IF . LPAREN exp0 RPAREN stmt
    (62) unmatchif -> IF . LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (60) matchif -> IF . LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    LPAREN          shift and go to state 163


state 141

    (73) retstmt -> RETURN . SEMICOLON
    (74) retstmt -> RETURN . exp0 SEMICOLON
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    SEMICOLON       shift and go to state 164
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 165
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 142

    (72) contistmt -> CONTINUE . SEMICOLON
    SEMICOLON       shift and go to state 166


state 143

    (71) breakstmt -> BREAK . SEMICOLON
    SEMICOLON       shift and go to state 167


state 144

    (70) dowhilestmt -> DO . blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    LBRACE          shift and go to state 106

    blockstmt                      shift and go to state 168

state 145

    (68) whilestmt -> WHILE . whilecondi stmt
    (69) whilecondi -> . LPAREN exp0 RPAREN
    LPAREN          shift and go to state 170

    whilecondi                     shift and go to state 169

state 146

    (63) forstmt -> FOR . LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    LPAREN          shift and go to state 171


state 147

    (31) paramdecl -> LPAREN paramlist RPAREN .
    INHERIT         reduce using rule 31 (paramdecl -> LPAREN paramlist RPAREN .)
    LBRACE          reduce using rule 31 (paramdecl -> LPAREN paramlist RPAREN .)


state 148

    (35) paramprime -> param COMMA . paramprime
    (34) paramprime -> . param
    (35) paramprime -> . param COMMA paramprime
    (36) param -> . OUT ID COLON typeof
    (37) param -> . INHERIT ID COLON typeof
    (38) param -> . ID COLON typeof
    (39) param -> . INHERIT OUT ID COLON typeof
    OUT             shift and go to state 111
    INHERIT         shift and go to state 113
    ID              shift and go to state 112

    param                          shift and go to state 110
    paramprime                     shift and go to state 172

state 149

    (36) param -> OUT ID . COLON typeof
    COLON           shift and go to state 173


state 150

    (38) param -> ID COLON . typeof
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19
    BOOLEAN         shift and go to state 20

    typeof                         shift and go to state 174
    arrtype                        shift and go to state 13
    atotype                        shift and go to state 14

state 151

    (37) param -> INHERIT ID . COLON typeof
    COLON           shift and go to state 175


state 152

    (39) param -> INHERIT OUT . ID COLON typeof
    ID              shift and go to state 176


state 153

    (22) arrtype -> ARRAY LBRACKET dime RBRACKET OF . atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19
    BOOLEAN         shift and go to state 20

    atotype                        shift and go to state 177

state 154

    (24) dime -> INTLIT COMMA dime .
    RBRACKET        reduce using rule 24 (dime -> INTLIT COMMA dime .)


state 155

    (29) funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt .
    ID              reduce using rule 29 (funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt .)
    $end            reduce using rule 29 (funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt .)


state 156

    (76) blockstmt -> LBRACE stmtlist RBRACE .
    ID              reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    $end            reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    IF              reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    LBRACE          reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    RETURN          reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    CONTINUE        reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    BREAK           reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    DO              reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    WHILE           reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    FOR             reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    RBRACE          reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    ELSE            reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)


state 157

    (45) stmtprime -> stmt stmtlist .
    RBRACE          reduce using rule 45 (stmtprime -> stmt stmtlist .)


state 158

    (44) stmtprime -> vardecl stmtlist .
    RBRACE          reduce using rule 44 (stmtprime -> vardecl stmtlist .)


state 159

    (8) vardecl -> ID COLON . typeof SEMICOLON
    (9) subvardecl -> COLON . typeof SEMICOLON
    (11) subvardecl -> COLON . typeof ASSIGNMENT
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19
    BOOLEAN         shift and go to state 20

    typeof                         shift and go to state 12
    arrtype                        shift and go to state 13
    atotype                        shift and go to state 14

state 160

    (75) callstmt -> ID LPAREN . explist RPAREN SEMICOLON
    (79) explist -> . empty
    (80) explist -> . expprime
    (118) empty -> .
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    RPAREN          reduce using rule 118 (empty -> .)
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    explist                        shift and go to state 178
    empty                          shift and go to state 73
    expprime                       shift and go to state 74
    exp0                           shift and go to state 75
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 161

    (58) assigstmt -> ID ASSIGNMENT . exp0 SEMICOLON
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 179
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 162

    (59) assigstmt -> ID LBRACKET . expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    expprime                       shift and go to state 180
    exp0                           shift and go to state 75
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 163

    (61) unmatchif -> IF LPAREN . exp0 RPAREN stmt
    (62) unmatchif -> IF LPAREN . exp0 RPAREN matchstmt ELSE unmatchif
    (60) matchif -> IF LPAREN . exp0 RPAREN matchstmt ELSE matchstmt
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 181
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 164

    (73) retstmt -> RETURN SEMICOLON .
    ID              reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    IF              reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    DO              reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 73 (retstmt -> RETURN SEMICOLON .)


state 165

    (74) retstmt -> RETURN exp0 . SEMICOLON
    SEMICOLON       shift and go to state 182


state 166

    (72) contistmt -> CONTINUE SEMICOLON .
    ID              reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    DO              reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)


state 167

    (71) breakstmt -> BREAK SEMICOLON .
    ID              reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    IF              reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    DO              reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)


state 168

    (70) dowhilestmt -> DO blockstmt . WHILE LPAREN exp0 RPAREN SEMICOLON
    WHILE           shift and go to state 183


state 169

    (68) whilestmt -> WHILE whilecondi . stmt
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    IF              shift and go to state 140
    LBRACE          shift and go to state 106
    ID              shift and go to state 185
    RETURN          shift and go to state 141
    CONTINUE        shift and go to state 142
    BREAK           shift and go to state 143
    DO              shift and go to state 144
    WHILE           shift and go to state 145
    FOR             shift and go to state 146

    stmt                           shift and go to state 184
    matchstmt                      shift and go to state 127
    unmatchif                      shift and go to state 128
    blockstmt                      shift and go to state 130
    callstmt                       shift and go to state 131
    retstmt                        shift and go to state 132
    contistmt                      shift and go to state 133
    breakstmt                      shift and go to state 134
    dowhilestmt                    shift and go to state 135
    whilestmt                      shift and go to state 136
    forstmt                        shift and go to state 137
    matchif                        shift and go to state 138
    assigstmt                      shift and go to state 139

state 170

    (69) whilecondi -> LPAREN . exp0 RPAREN
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 186
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 171

    (63) forstmt -> FOR LPAREN . scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (64) scaladecl -> . scalavar ASSIGNMENT exp0
    (65) scalavar -> . ID
    ID              shift and go to state 189

    scaladecl                      shift and go to state 187
    scalavar                       shift and go to state 188

state 172

    (35) paramprime -> param COMMA paramprime .
    RPAREN          reduce using rule 35 (paramprime -> param COMMA paramprime .)


state 173

    (36) param -> OUT ID COLON . typeof
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19
    BOOLEAN         shift and go to state 20

    typeof                         shift and go to state 190
    arrtype                        shift and go to state 13
    atotype                        shift and go to state 14

state 174

    (38) param -> ID COLON typeof .
    COMMA           reduce using rule 38 (param -> ID COLON typeof .)
    RPAREN          reduce using rule 38 (param -> ID COLON typeof .)


state 175

    (37) param -> INHERIT ID COLON . typeof
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19
    BOOLEAN         shift and go to state 20

    typeof                         shift and go to state 191
    arrtype                        shift and go to state 13
    atotype                        shift and go to state 14

state 176

    (39) param -> INHERIT OUT ID . COLON typeof
    COLON           shift and go to state 192


state 177

    (22) arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .
    SEMICOLON       reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)
    ASSIGNMENT      reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)
    LPAREN          reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)
    COMMA           reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)
    RPAREN          reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)


state 178

    (75) callstmt -> ID LPAREN explist . RPAREN SEMICOLON
    RPAREN          shift and go to state 193


state 179

    (58) assigstmt -> ID ASSIGNMENT exp0 . SEMICOLON
    SEMICOLON       shift and go to state 194


state 180

    (59) assigstmt -> ID LBRACKET expprime . RBRACKET ASSIGNMENT exp0 SEMICOLON
    RBRACKET        shift and go to state 195


state 181

    (61) unmatchif -> IF LPAREN exp0 . RPAREN stmt
    (62) unmatchif -> IF LPAREN exp0 . RPAREN matchstmt ELSE unmatchif
    (60) matchif -> IF LPAREN exp0 . RPAREN matchstmt ELSE matchstmt
    RPAREN          shift and go to state 196


state 182

    (74) retstmt -> RETURN exp0 SEMICOLON .
    ID              reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    IF              reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    LBRACE          reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    RETURN          reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    CONTINUE        reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    BREAK           reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    DO              reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    WHILE           reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    FOR             reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    RBRACE          reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    ELSE            reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)


state 183

    (70) dowhilestmt -> DO blockstmt WHILE . LPAREN exp0 RPAREN SEMICOLON
    LPAREN          shift and go to state 197


state 184

    (68) whilestmt -> WHILE whilecondi stmt .
    ID              reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    IF              reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    LBRACE          reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    RETURN          reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    CONTINUE        reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    BREAK           reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    DO              reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    WHILE           reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    FOR             reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    RBRACE          reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    ELSE            reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)


state 185

    (75) callstmt -> ID . LPAREN explist RPAREN SEMICOLON
    (58) assigstmt -> ID . ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> ID . LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    LPAREN          shift and go to state 160
    ASSIGNMENT      shift and go to state 161
    LBRACKET        shift and go to state 162


state 186

    (69) whilecondi -> LPAREN exp0 . RPAREN
    RPAREN          shift and go to state 198


state 187

    (63) forstmt -> FOR LPAREN scaladecl . COMMA condifor COMMA updatefor RPAREN stmt
    COMMA           shift and go to state 199


state 188

    (64) scaladecl -> scalavar . ASSIGNMENT exp0
    ASSIGNMENT      shift and go to state 200


state 189

    (65) scalavar -> ID .
    ASSIGNMENT      reduce using rule 65 (scalavar -> ID .)


state 190

    (36) param -> OUT ID COLON typeof .
    COMMA           reduce using rule 36 (param -> OUT ID COLON typeof .)
    RPAREN          reduce using rule 36 (param -> OUT ID COLON typeof .)


state 191

    (37) param -> INHERIT ID COLON typeof .
    COMMA           reduce using rule 37 (param -> INHERIT ID COLON typeof .)
    RPAREN          reduce using rule 37 (param -> INHERIT ID COLON typeof .)


state 192

    (39) param -> INHERIT OUT ID COLON . typeof
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19
    BOOLEAN         shift and go to state 20

    typeof                         shift and go to state 201
    arrtype                        shift and go to state 13
    atotype                        shift and go to state 14

state 193

    (75) callstmt -> ID LPAREN explist RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 202


state 194

    (58) assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .
    ID              reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    IF              reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    LBRACE          reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    RETURN          reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    CONTINUE        reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    BREAK           reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    DO              reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    WHILE           reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    FOR             reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    RBRACE          reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    ELSE            reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)


state 195

    (59) assigstmt -> ID LBRACKET expprime RBRACKET . ASSIGNMENT exp0 SEMICOLON
    ASSIGNMENT      shift and go to state 203


state 196

    (61) unmatchif -> IF LPAREN exp0 RPAREN . stmt
    (62) unmatchif -> IF LPAREN exp0 RPAREN . matchstmt ELSE unmatchif
    (60) matchif -> IF LPAREN exp0 RPAREN . matchstmt ELSE matchstmt
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    IF              shift and go to state 140
    LBRACE          shift and go to state 106
    ID              shift and go to state 185
    RETURN          shift and go to state 141
    CONTINUE        shift and go to state 142
    BREAK           shift and go to state 143
    DO              shift and go to state 144
    WHILE           shift and go to state 145
    FOR             shift and go to state 146

    stmt                           shift and go to state 204
    matchstmt                      shift and go to state 205
    unmatchif                      shift and go to state 128
    blockstmt                      shift and go to state 130
    callstmt                       shift and go to state 131
    retstmt                        shift and go to state 132
    contistmt                      shift and go to state 133
    breakstmt                      shift and go to state 134
    dowhilestmt                    shift and go to state 135
    whilestmt                      shift and go to state 136
    forstmt                        shift and go to state 137
    matchif                        shift and go to state 138
    assigstmt                      shift and go to state 139

state 197

    (70) dowhilestmt -> DO blockstmt WHILE LPAREN . exp0 RPAREN SEMICOLON
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 206
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 198

    (69) whilecondi -> LPAREN exp0 RPAREN .
    IF              reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    LBRACE          reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    ID              reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    RETURN          reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    CONTINUE        reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    BREAK           reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    DO              reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    WHILE           reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    FOR             reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)


state 199

    (63) forstmt -> FOR LPAREN scaladecl COMMA . condifor COMMA updatefor RPAREN stmt
    (66) condifor -> . exp0
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    condifor                       shift and go to state 207
    exp0                           shift and go to state 208
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 200

    (64) scaladecl -> scalavar ASSIGNMENT . exp0
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 209
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 201

    (39) param -> INHERIT OUT ID COLON typeof .
    COMMA           reduce using rule 39 (param -> INHERIT OUT ID COLON typeof .)
    RPAREN          reduce using rule 39 (param -> INHERIT OUT ID COLON typeof .)


state 202

    (75) callstmt -> ID LPAREN explist RPAREN SEMICOLON .
    ID              reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    IF              reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    LBRACE          reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    RETURN          reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    BREAK           reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    DO              reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    WHILE           reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    FOR             reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    RBRACE          reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    ELSE            reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)


state 203

    (59) assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT . exp0 SEMICOLON
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    exp0                           shift and go to state 210
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 204

    (61) unmatchif -> IF LPAREN exp0 RPAREN stmt .
    ID              reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    IF              reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    LBRACE          reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    RETURN          reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    CONTINUE        reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    BREAK           reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    DO              reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    WHILE           reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    FOR             reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    RBRACE          reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    ELSE            reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)


state 205

    (62) unmatchif -> IF LPAREN exp0 RPAREN matchstmt . ELSE unmatchif
    (60) matchif -> IF LPAREN exp0 RPAREN matchstmt . ELSE matchstmt
    (46) stmt -> matchstmt .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 211
    ID              reduce using rule 46 (stmt -> matchstmt .)
    IF              reduce using rule 46 (stmt -> matchstmt .)
    LBRACE          reduce using rule 46 (stmt -> matchstmt .)
    RETURN          reduce using rule 46 (stmt -> matchstmt .)
    CONTINUE        reduce using rule 46 (stmt -> matchstmt .)
    BREAK           reduce using rule 46 (stmt -> matchstmt .)
    DO              reduce using rule 46 (stmt -> matchstmt .)
    WHILE           reduce using rule 46 (stmt -> matchstmt .)
    FOR             reduce using rule 46 (stmt -> matchstmt .)
    RBRACE          reduce using rule 46 (stmt -> matchstmt .)


state 206

    (70) dowhilestmt -> DO blockstmt WHILE LPAREN exp0 . RPAREN SEMICOLON
    RPAREN          shift and go to state 212


state 207

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor . COMMA updatefor RPAREN stmt
    COMMA           shift and go to state 213


state 208

    (66) condifor -> exp0 .
    COMMA           reduce using rule 66 (condifor -> exp0 .)


state 209

    (64) scaladecl -> scalavar ASSIGNMENT exp0 .
    COMMA           reduce using rule 64 (scaladecl -> scalavar ASSIGNMENT exp0 .)


state 210

    (59) assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 . SEMICOLON
    SEMICOLON       shift and go to state 214


state 211

    (62) unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE . unmatchif
    (60) matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE . matchstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    IF              shift and go to state 140
    LBRACE          shift and go to state 106
    ID              shift and go to state 185
    RETURN          shift and go to state 141
    CONTINUE        shift and go to state 142
    BREAK           shift and go to state 143
    DO              shift and go to state 144
    WHILE           shift and go to state 145
    FOR             shift and go to state 146

    matchstmt                      shift and go to state 215
    unmatchif                      shift and go to state 216
    blockstmt                      shift and go to state 130
    callstmt                       shift and go to state 131
    retstmt                        shift and go to state 132
    contistmt                      shift and go to state 133
    breakstmt                      shift and go to state 134
    dowhilestmt                    shift and go to state 135
    whilestmt                      shift and go to state 136
    forstmt                        shift and go to state 137
    matchif                        shift and go to state 138
    assigstmt                      shift and go to state 139

state 212

    (70) dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 217


state 213

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA . updatefor RPAREN stmt
    (67) updatefor -> . exp0
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 30
    MINUS           shift and go to state 28
    ID              shift and go to state 21
    STRINGLIT       shift and go to state 37
    BOOLEANLIT      shift and go to state 38
    FLOATLIT        shift and go to state 39
    INTLIT          shift and go to state 40
    LPAREN          shift and go to state 41
    LBRACE          shift and go to state 42

    updatefor                      shift and go to state 218
    exp0                           shift and go to state 219
    exp1                           shift and go to state 23
    exp2                           shift and go to state 24
    exp3                           shift and go to state 25
    exp4                           shift and go to state 26
    exp5                           shift and go to state 27
    exp6                           shift and go to state 29
    exp7                           shift and go to state 31
    exp8                           shift and go to state 32
    exp9                           shift and go to state 33
    funcall                        shift and go to state 34
    exp10                          shift and go to state 35
    arraylit                       shift and go to state 36

state 214

    (59) assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .
    ID              reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    IF              reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    LBRACE          reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    RETURN          reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    CONTINUE        reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    BREAK           reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    DO              reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    WHILE           reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    FOR             reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    RBRACE          reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    ELSE            reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)


state 215

    (60) matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .
    ID              reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    IF              reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    LBRACE          reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    RETURN          reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    CONTINUE        reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    BREAK           reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    DO              reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    WHILE           reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    FOR             reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    RBRACE          reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    ELSE            reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)


state 216

    (62) unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .
    ID              reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    IF              reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    LBRACE          reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    RETURN          reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    CONTINUE        reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    BREAK           reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    DO              reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    WHILE           reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    FOR             reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    RBRACE          reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    ELSE            reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)


state 217

    (70) dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .
    ID              reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    IF              reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    LBRACE          reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    RETURN          reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    BREAK           reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    DO              reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    WHILE           reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    FOR             reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    RBRACE          reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    ELSE            reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)


state 218

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor . RPAREN stmt
    RPAREN          shift and go to state 220


state 219

    (67) updatefor -> exp0 .
    RPAREN          reduce using rule 67 (updatefor -> exp0 .)


state 220

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN . stmt
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    IF              shift and go to state 140
    LBRACE          shift and go to state 106
    ID              shift and go to state 185
    RETURN          shift and go to state 141
    CONTINUE        shift and go to state 142
    BREAK           shift and go to state 143
    DO              shift and go to state 144
    WHILE           shift and go to state 145
    FOR             shift and go to state 146

    stmt                           shift and go to state 221
    matchstmt                      shift and go to state 127
    unmatchif                      shift and go to state 128
    blockstmt                      shift and go to state 130
    callstmt                       shift and go to state 131
    retstmt                        shift and go to state 132
    contistmt                      shift and go to state 133
    breakstmt                      shift and go to state 134
    dowhilestmt                    shift and go to state 135
    whilestmt                      shift and go to state 136
    forstmt                        shift and go to state 137
    matchif                        shift and go to state 138
    assigstmt                      shift and go to state 139

state 221

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .
    ID              reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    IF              reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    LBRACE          reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    RETURN          reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    CONTINUE        reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    BREAK           reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    DO              reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    WHILE           reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    FOR             reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    RBRACE          reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    ELSE            reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)


Conflicts:

shift/reduce conflict for ID in state 9 resolved as shift
shift/reduce conflict for LBRACE in state 9 resolved as shift
shift/reduce conflict for NOT in state 76 resolved as shift
shift/reduce conflict for MINUS in state 76 resolved as shift
shift/reduce conflict for ID in state 76 resolved as shift
shift/reduce conflict for STRINGLIT in state 76 resolved as shift
shift/reduce conflict for BOOLEANLIT in state 76 resolved as shift
shift/reduce conflict for FLOATLIT in state 76 resolved as shift
shift/reduce conflict for INTLIT in state 76 resolved as shift
shift/reduce conflict for LPAREN in state 76 resolved as shift
shift/reduce conflict for LBRACE in state 76 resolved as shift
shift/reduce conflict for DOUBLECOLON in state 84 resolved as shift
shift/reduce conflict for MUL in state 94 resolved as shift
shift/reduce conflict for DIV in state 94 resolved as shift
shift/reduce conflict for MOD in state 94 resolved as shift
shift/reduce conflict for MUL in state 95 resolved as shift
shift/reduce conflict for DIV in state 95 resolved as shift
shift/reduce conflict for MOD in state 95 resolved as shift
shift/reduce conflict for ELSE in state 205 resolved as shift
reduce/reduce conflict in state 49 resolved using rule vardecl -> ID COLON typeof SEMICOLON
rejected rule (subvardecl -> COLON typeof SEMICOLON) in state 49
reduce/reduce conflict in state 94 resolved using rule exp4 -> exp3 PLUS exp4
rejected rule (exp3 -> exp4) in state 94
reduce/reduce conflict in state 95 resolved using rule exp4 -> exp3 MINUS exp4
rejected rule (exp3 -> exp4) in state 95
reduce/reduce conflict in state 125 resolved using rule stmtprime -> stmt
rejected rule (empty -> <empty>) in state 125
reduce/reduce conflict in state 126 resolved using rule stmtprime -> vardecl
rejected rule (empty -> <empty>) in state 126