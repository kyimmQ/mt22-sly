Grammar:

Rule 0     S' -> program
Rule 1     program -> decllist
Rule 2     decllist -> decl decllist
Rule 3     decllist -> decl
Rule 4     decl -> funcdecl
Rule 5     decl -> vardecl
Rule 6     vardecl -> ID subvardecl exp0 SEMICOLON
Rule 7     vardecl -> ID subvardecl2
Rule 8     vardecl -> ID COLON typeof SEMICOLON
Rule 9     subvardecl -> COLON typeof ASSIGNMENT
Rule 10    subvardecl -> COMMA ID subvardecl exp0 COMMA
Rule 11    subvardecl2 -> COMMA ID subvardecl3
Rule 12    subvardecl3 -> COLON typeof SEMICOLON
Rule 13    idlist -> ID
Rule 14    idlist -> ID COMMA idlist
Rule 15    typeof -> arrtype
Rule 16    typeof -> atotype
Rule 17    typeof -> AUTO
Rule 18    atotype -> STRING
Rule 19    atotype -> FLOAT
Rule 20    atotype -> INTEGER
Rule 21    atotype -> BOOLEAN
Rule 22    arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype
Rule 23    dime -> INTLIT
Rule 24    dime -> INTLIT COMMA dime
Rule 25    returntype -> arrtype
Rule 26    returntype -> atotype
Rule 27    returntype -> VOID
Rule 28    returntype -> AUTO
Rule 29    funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt
Rule 30    funcdecl -> ID COLON FUNCTION returntype paramdecl blockstmt
Rule 31    paramdecl -> LPAREN paramlist RPAREN
Rule 32    paramlist -> empty
Rule 33    paramlist -> paramprime
Rule 34    paramprime -> param
Rule 35    paramprime -> param COMMA paramprime
Rule 36    param -> OUT ID COLON typeof
Rule 37    param -> INHERIT ID COLON typeof
Rule 38    param -> ID COLON typeof
Rule 39    param -> INHERIT OUT ID COLON typeof
Rule 40    stmtlist -> empty
Rule 41    stmtlist -> stmtprime
Rule 42    stmtprime -> stmt
Rule 43    stmtprime -> vardecl
Rule 44    stmtprime -> vardecl stmtlist
Rule 45    stmtprime -> stmt stmtlist
Rule 46    stmt -> matchstmt
Rule 47    stmt -> unmatchif
Rule 48    matchstmt -> blockstmt
Rule 49    matchstmt -> callstmt
Rule 50    matchstmt -> retstmt
Rule 51    matchstmt -> contistmt
Rule 52    matchstmt -> breakstmt
Rule 53    matchstmt -> dowhilestmt
Rule 54    matchstmt -> whilestmt
Rule 55    matchstmt -> forstmt
Rule 56    matchstmt -> matchif
Rule 57    matchstmt -> assigstmt
Rule 58    assigstmt -> ID ASSIGNMENT exp0 SEMICOLON
Rule 59    assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
Rule 60    matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
Rule 61    unmatchif -> IF LPAREN exp0 RPAREN stmt
Rule 62    unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
Rule 63    forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
Rule 64    scaladecl -> scalavar ASSIGNMENT exp0
Rule 65    scalavar -> ID
Rule 66    condifor -> exp0
Rule 67    updatefor -> exp0
Rule 68    whilestmt -> WHILE whilecondi stmt
Rule 69    whilecondi -> LPAREN exp0 RPAREN
Rule 70    dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
Rule 71    breakstmt -> BREAK SEMICOLON
Rule 72    contistmt -> CONTINUE SEMICOLON
Rule 73    retstmt -> RETURN SEMICOLON
Rule 74    retstmt -> RETURN exp0 SEMICOLON
Rule 75    callstmt -> ID LPAREN explist RPAREN SEMICOLON
Rule 76    blockstmt -> LBRACE stmtlist RBRACE
Rule 77    funcall -> ID LPAREN explist RPAREN
Rule 78    arraylit -> LBRACE explist RBRACE
Rule 79    explist -> empty
Rule 80    explist -> expprime
Rule 81    expprime -> exp0
Rule 82    expprime -> exp0 COMMA expprime
Rule 83    exp1 -> exp2
Rule 84    exp1 -> exp2 EQUAL exp2
Rule 85    exp1 -> exp2 NOTEQUAL exp2
Rule 86    exp1 -> exp2 LESSTHAN exp2
Rule 87    exp1 -> exp2 LEQ exp2
Rule 88    exp1 -> exp2 GREATERTHAN exp2
Rule 89    exp1 -> exp2 GEQ exp2
Rule 90    exp1 -> exp1 DOUBLECOLON exp1
Rule 91    exp0 -> exp1
Rule 92    exp2 -> exp3
Rule 93    exp2 -> exp2 AND exp3
Rule 94    exp2 -> exp2 OR exp3
Rule 95    exp4 -> exp5
Rule 96    exp4 -> exp4 MUL exp5
Rule 97    exp4 -> exp4 DIV exp5
Rule 98    exp4 -> exp4 MOD exp5
Rule 99    exp4 -> exp3 PLUS exp4
Rule 100   exp4 -> exp3 MINUS exp4
Rule 101   exp3 -> exp4
Rule 102   exp5 -> exp6
Rule 103   exp5 -> NOT exp5
Rule 104   exp6 -> exp7
Rule 105   exp6 -> MINUS exp6
Rule 106   exp7 -> exp8
Rule 107   exp7 -> ID LBRACKET expprime RBRACKET
Rule 108   exp8 -> exp9
Rule 109   exp8 -> funcall
Rule 110   exp9 -> exp10
Rule 111   exp9 -> arraylit
Rule 112   exp9 -> ID
Rule 113   exp9 -> STRINGLIT
Rule 114   exp9 -> BOOLEANLIT
Rule 115   exp9 -> FLOATLIT
Rule 116   exp9 -> INTLIT
Rule 117   exp10 -> LPAREN exp0 RPAREN
Rule 118   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 93
ARRAY                : 22
ASSIGNMENT           : 9 58 59 64
AUTO                 : 17 28
BOOLEAN              : 21
BOOLEANLIT           : 114
BREAK                : 71
COLON                : 8 9 12 29 30 36 37 38 39
COMMA                : 10 10 11 14 24 35 63 63 82
CONTINUE             : 72
DIV                  : 97
DO                   : 70
DOUBLECOLON          : 90
ELSE                 : 60 62
EQUAL                : 84
FLOAT                : 19
FLOATLIT             : 115
FOR                  : 63
FUNCTION             : 29 30
GEQ                  : 89
GREATERTHAN          : 88
ID                   : 6 7 8 10 11 13 14 29 29 30 36 37 38 39 58 59 65 75 77 107 112
IF                   : 60 61 62
INHERIT              : 29 37 39
INTEGER              : 20
INTLIT               : 23 24 116
LBRACE               : 76 78
LBRACKET             : 22 59 107
LEQ                  : 87
LESSTHAN             : 86
LPAREN               : 31 60 61 62 63 69 70 75 77 117
MINUS                : 100 105
MOD                  : 98
MUL                  : 96
NOT                  : 103
NOTEQUAL             : 85
OF                   : 22
OR                   : 94
OUT                  : 36 39
PLUS                 : 99
RBRACE               : 76 78
RBRACKET             : 22 59 107
RETURN               : 73 74
RPAREN               : 31 60 61 62 63 69 70 75 77 117
SEMICOLON            : 6 8 12 58 59 70 71 72 73 74 75
STRING               : 18
STRINGLIT            : 113
VOID                 : 27
WHILE                : 68 70
error                : 

Nonterminals, with rules where they appear:

arraylit             : 111
arrtype              : 15 25
assigstmt            : 57
atotype              : 16 22 26
blockstmt            : 29 30 48 70
breakstmt            : 52
callstmt             : 49
condifor             : 63
contistmt            : 51
decl                 : 2 3
decllist             : 1 2
dime                 : 22 24
dowhilestmt          : 53
empty                : 32 40 79
exp0                 : 6 10 58 59 60 61 62 64 66 67 69 70 74 81 82 117
exp1                 : 90 90 91
exp10                : 110
exp2                 : 83 84 84 85 85 86 86 87 87 88 88 89 89 93 94
exp3                 : 92 93 94 99 100
exp4                 : 96 97 98 99 100 101
exp5                 : 95 96 97 98 103
exp6                 : 102 105
exp7                 : 104
exp8                 : 106
exp9                 : 108
explist              : 75 77 78
expprime             : 59 80 82 107
forstmt              : 55
funcall              : 109
funcdecl             : 4
idlist               : 14
matchif              : 56
matchstmt            : 46 60 60 62
param                : 34 35
paramdecl            : 29 30
paramlist            : 31
paramprime           : 33 35
program              : 0
retstmt              : 50
returntype           : 29 30
scaladecl            : 63
scalavar             : 64
stmt                 : 42 45 61 63 68
stmtlist             : 44 45 76
stmtprime            : 41
subvardecl           : 6 10
subvardecl2          : 7
subvardecl3          : 11
typeof               : 8 9 12 36 37 38 39
unmatchif            : 47 62
updatefor            : 63
vardecl              : 5 43 44
whilecondi           : 68
whilestmt            : 54


state 0

    (0) S' -> . program
    (1) program -> . decllist
    (2) decllist -> . decl decllist
    (3) decllist -> . decl
    (4) decl -> . funcdecl
    (5) decl -> . vardecl
    (29) funcdecl -> . ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> . ID COLON FUNCTION returntype paramdecl blockstmt
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl2
    (8) vardecl -> . ID COLON typeof SEMICOLON
    ID              shift and go to state 6

    program                        shift and go to state 1
    decllist                       shift and go to state 2
    decl                           shift and go to state 3
    funcdecl                       shift and go to state 4
    vardecl                        shift and go to state 5

state 1

    (0) S' -> program .


state 2

    (1) program -> decllist .
    $end            reduce using rule 1 (program -> decllist .)


state 3

    (2) decllist -> decl . decllist
    (3) decllist -> decl .
    (2) decllist -> . decl decllist
    (3) decllist -> . decl
    (4) decl -> . funcdecl
    (5) decl -> . vardecl
    (29) funcdecl -> . ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> . ID COLON FUNCTION returntype paramdecl blockstmt
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl2
    (8) vardecl -> . ID COLON typeof SEMICOLON
    $end            reduce using rule 3 (decllist -> decl .)
    ID              shift and go to state 6

    decl                           shift and go to state 3
    decllist                       shift and go to state 7
    funcdecl                       shift and go to state 4
    vardecl                        shift and go to state 5

state 4

    (4) decl -> funcdecl .
    ID              reduce using rule 4 (decl -> funcdecl .)
    $end            reduce using rule 4 (decl -> funcdecl .)


state 5

    (5) decl -> vardecl .
    ID              reduce using rule 5 (decl -> vardecl .)
    $end            reduce using rule 5 (decl -> vardecl .)


state 6

    (29) funcdecl -> ID . COLON FUNCTION returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> ID . COLON FUNCTION returntype paramdecl blockstmt
    (6) vardecl -> ID . subvardecl exp0 SEMICOLON
    (7) vardecl -> ID . subvardecl2
    (8) vardecl -> ID . COLON typeof SEMICOLON
    (9) subvardecl -> . COLON typeof ASSIGNMENT
    (10) subvardecl -> . COMMA ID subvardecl exp0 COMMA
    (11) subvardecl2 -> . COMMA ID subvardecl3
    COLON           shift and go to state 8
    COMMA           shift and go to state 11

    subvardecl                     shift and go to state 9
    subvardecl2                    shift and go to state 10

state 7

    (2) decllist -> decl decllist .
    $end            reduce using rule 2 (decllist -> decl decllist .)


state 8

    (29) funcdecl -> ID COLON . FUNCTION returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> ID COLON . FUNCTION returntype paramdecl blockstmt
    (8) vardecl -> ID COLON . typeof SEMICOLON
    (9) subvardecl -> COLON . typeof ASSIGNMENT
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    FUNCTION        shift and go to state 12
    AUTO            shift and go to state 16
    ARRAY           shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    typeof                         shift and go to state 13
    arrtype                        shift and go to state 14
    atotype                        shift and go to state 15

state 9

    (6) vardecl -> ID subvardecl . exp0 SEMICOLON
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 23
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 10

    (7) vardecl -> ID subvardecl2 .
    ID              reduce using rule 7 (vardecl -> ID subvardecl2 .)
    $end            reduce using rule 7 (vardecl -> ID subvardecl2 .)
    IF              reduce using rule 7 (vardecl -> ID subvardecl2 .)
    LBRACE          reduce using rule 7 (vardecl -> ID subvardecl2 .)
    RETURN          reduce using rule 7 (vardecl -> ID subvardecl2 .)
    CONTINUE        reduce using rule 7 (vardecl -> ID subvardecl2 .)
    BREAK           reduce using rule 7 (vardecl -> ID subvardecl2 .)
    DO              reduce using rule 7 (vardecl -> ID subvardecl2 .)
    WHILE           reduce using rule 7 (vardecl -> ID subvardecl2 .)
    FOR             reduce using rule 7 (vardecl -> ID subvardecl2 .)
    RBRACE          reduce using rule 7 (vardecl -> ID subvardecl2 .)


state 11

    (10) subvardecl -> COMMA . ID subvardecl exp0 COMMA
    (11) subvardecl2 -> COMMA . ID subvardecl3
    ID              shift and go to state 44


state 12

    (29) funcdecl -> ID COLON FUNCTION . returntype paramdecl INHERIT ID blockstmt
    (30) funcdecl -> ID COLON FUNCTION . returntype paramdecl blockstmt
    (25) returntype -> . arrtype
    (26) returntype -> . atotype
    (27) returntype -> . VOID
    (28) returntype -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    VOID            shift and go to state 48
    AUTO            shift and go to state 49
    ARRAY           shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    returntype                     shift and go to state 45
    arrtype                        shift and go to state 46
    atotype                        shift and go to state 47

state 13

    (8) vardecl -> ID COLON typeof . SEMICOLON
    (9) subvardecl -> COLON typeof . ASSIGNMENT
    SEMICOLON       shift and go to state 50
    ASSIGNMENT      shift and go to state 51


state 14

    (15) typeof -> arrtype .
    SEMICOLON       reduce using rule 15 (typeof -> arrtype .)
    ASSIGNMENT      reduce using rule 15 (typeof -> arrtype .)
    COMMA           reduce using rule 15 (typeof -> arrtype .)
    RPAREN          reduce using rule 15 (typeof -> arrtype .)


state 15

    (16) typeof -> atotype .
    SEMICOLON       reduce using rule 16 (typeof -> atotype .)
    ASSIGNMENT      reduce using rule 16 (typeof -> atotype .)
    COMMA           reduce using rule 16 (typeof -> atotype .)
    RPAREN          reduce using rule 16 (typeof -> atotype .)


state 16

    (17) typeof -> AUTO .
    SEMICOLON       reduce using rule 17 (typeof -> AUTO .)
    ASSIGNMENT      reduce using rule 17 (typeof -> AUTO .)
    COMMA           reduce using rule 17 (typeof -> AUTO .)
    RPAREN          reduce using rule 17 (typeof -> AUTO .)


state 17

    (22) arrtype -> ARRAY . LBRACKET dime RBRACKET OF atotype
    LBRACKET        shift and go to state 52


state 18

    (18) atotype -> STRING .
    SEMICOLON       reduce using rule 18 (atotype -> STRING .)
    ASSIGNMENT      reduce using rule 18 (atotype -> STRING .)
    LPAREN          reduce using rule 18 (atotype -> STRING .)
    COMMA           reduce using rule 18 (atotype -> STRING .)
    RPAREN          reduce using rule 18 (atotype -> STRING .)


state 19

    (19) atotype -> FLOAT .
    SEMICOLON       reduce using rule 19 (atotype -> FLOAT .)
    ASSIGNMENT      reduce using rule 19 (atotype -> FLOAT .)
    LPAREN          reduce using rule 19 (atotype -> FLOAT .)
    COMMA           reduce using rule 19 (atotype -> FLOAT .)
    RPAREN          reduce using rule 19 (atotype -> FLOAT .)


state 20

    (20) atotype -> INTEGER .
    SEMICOLON       reduce using rule 20 (atotype -> INTEGER .)
    ASSIGNMENT      reduce using rule 20 (atotype -> INTEGER .)
    LPAREN          reduce using rule 20 (atotype -> INTEGER .)
    COMMA           reduce using rule 20 (atotype -> INTEGER .)
    RPAREN          reduce using rule 20 (atotype -> INTEGER .)


state 21

    (21) atotype -> BOOLEAN .
    SEMICOLON       reduce using rule 21 (atotype -> BOOLEAN .)
    ASSIGNMENT      reduce using rule 21 (atotype -> BOOLEAN .)
    LPAREN          reduce using rule 21 (atotype -> BOOLEAN .)
    COMMA           reduce using rule 21 (atotype -> BOOLEAN .)
    RPAREN          reduce using rule 21 (atotype -> BOOLEAN .)


state 22

    (107) exp7 -> ID . LBRACKET expprime RBRACKET
    (112) exp9 -> ID .
    (77) funcall -> ID . LPAREN explist RPAREN
    LBRACKET        shift and go to state 53
    MUL             reduce using rule 112 (exp9 -> ID .)
    DIV             reduce using rule 112 (exp9 -> ID .)
    MOD             reduce using rule 112 (exp9 -> ID .)
    PLUS            reduce using rule 112 (exp9 -> ID .)
    MINUS           reduce using rule 112 (exp9 -> ID .)
    EQUAL           reduce using rule 112 (exp9 -> ID .)
    NOTEQUAL        reduce using rule 112 (exp9 -> ID .)
    LESSTHAN        reduce using rule 112 (exp9 -> ID .)
    LEQ             reduce using rule 112 (exp9 -> ID .)
    GREATERTHAN     reduce using rule 112 (exp9 -> ID .)
    GEQ             reduce using rule 112 (exp9 -> ID .)
    AND             reduce using rule 112 (exp9 -> ID .)
    OR              reduce using rule 112 (exp9 -> ID .)
    DOUBLECOLON     reduce using rule 112 (exp9 -> ID .)
    SEMICOLON       reduce using rule 112 (exp9 -> ID .)
    RPAREN          reduce using rule 112 (exp9 -> ID .)
    COMMA           reduce using rule 112 (exp9 -> ID .)
    RBRACE          reduce using rule 112 (exp9 -> ID .)
    RBRACKET        reduce using rule 112 (exp9 -> ID .)
    LPAREN          shift and go to state 54


state 23

    (6) vardecl -> ID subvardecl exp0 . SEMICOLON
    SEMICOLON       shift and go to state 55


state 24

    (91) exp0 -> exp1 .
    (90) exp1 -> exp1 . DOUBLECOLON exp1
    SEMICOLON       reduce using rule 91 (exp0 -> exp1 .)
    RPAREN          reduce using rule 91 (exp0 -> exp1 .)
    COMMA           reduce using rule 91 (exp0 -> exp1 .)
    RBRACE          reduce using rule 91 (exp0 -> exp1 .)
    RBRACKET        reduce using rule 91 (exp0 -> exp1 .)
    DOUBLECOLON     shift and go to state 56


state 25

    (83) exp1 -> exp2 .
    (84) exp1 -> exp2 . EQUAL exp2
    (85) exp1 -> exp2 . NOTEQUAL exp2
    (86) exp1 -> exp2 . LESSTHAN exp2
    (87) exp1 -> exp2 . LEQ exp2
    (88) exp1 -> exp2 . GREATERTHAN exp2
    (89) exp1 -> exp2 . GEQ exp2
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 83 (exp1 -> exp2 .)
    SEMICOLON       reduce using rule 83 (exp1 -> exp2 .)
    RPAREN          reduce using rule 83 (exp1 -> exp2 .)
    COMMA           reduce using rule 83 (exp1 -> exp2 .)
    RBRACE          reduce using rule 83 (exp1 -> exp2 .)
    RBRACKET        reduce using rule 83 (exp1 -> exp2 .)
    EQUAL           shift and go to state 57
    NOTEQUAL        shift and go to state 58
    LESSTHAN        shift and go to state 59
    LEQ             shift and go to state 60
    GREATERTHAN     shift and go to state 61
    GEQ             shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64


state 26

    (92) exp2 -> exp3 .
    (99) exp4 -> exp3 . PLUS exp4
    (100) exp4 -> exp3 . MINUS exp4
    EQUAL           reduce using rule 92 (exp2 -> exp3 .)
    NOTEQUAL        reduce using rule 92 (exp2 -> exp3 .)
    LESSTHAN        reduce using rule 92 (exp2 -> exp3 .)
    LEQ             reduce using rule 92 (exp2 -> exp3 .)
    GREATERTHAN     reduce using rule 92 (exp2 -> exp3 .)
    GEQ             reduce using rule 92 (exp2 -> exp3 .)
    AND             reduce using rule 92 (exp2 -> exp3 .)
    OR              reduce using rule 92 (exp2 -> exp3 .)
    DOUBLECOLON     reduce using rule 92 (exp2 -> exp3 .)
    SEMICOLON       reduce using rule 92 (exp2 -> exp3 .)
    RPAREN          reduce using rule 92 (exp2 -> exp3 .)
    COMMA           reduce using rule 92 (exp2 -> exp3 .)
    RBRACE          reduce using rule 92 (exp2 -> exp3 .)
    RBRACKET        reduce using rule 92 (exp2 -> exp3 .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 27

    (101) exp3 -> exp4 .
    (96) exp4 -> exp4 . MUL exp5
    (97) exp4 -> exp4 . DIV exp5
    (98) exp4 -> exp4 . MOD exp5
    PLUS            reduce using rule 101 (exp3 -> exp4 .)
    MINUS           reduce using rule 101 (exp3 -> exp4 .)
    EQUAL           reduce using rule 101 (exp3 -> exp4 .)
    NOTEQUAL        reduce using rule 101 (exp3 -> exp4 .)
    LESSTHAN        reduce using rule 101 (exp3 -> exp4 .)
    LEQ             reduce using rule 101 (exp3 -> exp4 .)
    GREATERTHAN     reduce using rule 101 (exp3 -> exp4 .)
    GEQ             reduce using rule 101 (exp3 -> exp4 .)
    AND             reduce using rule 101 (exp3 -> exp4 .)
    OR              reduce using rule 101 (exp3 -> exp4 .)
    DOUBLECOLON     reduce using rule 101 (exp3 -> exp4 .)
    SEMICOLON       reduce using rule 101 (exp3 -> exp4 .)
    RPAREN          reduce using rule 101 (exp3 -> exp4 .)
    COMMA           reduce using rule 101 (exp3 -> exp4 .)
    RBRACE          reduce using rule 101 (exp3 -> exp4 .)
    RBRACKET        reduce using rule 101 (exp3 -> exp4 .)
    MUL             shift and go to state 67
    DIV             shift and go to state 68
    MOD             shift and go to state 69


state 28

    (95) exp4 -> exp5 .
    MUL             reduce using rule 95 (exp4 -> exp5 .)
    DIV             reduce using rule 95 (exp4 -> exp5 .)
    MOD             reduce using rule 95 (exp4 -> exp5 .)
    PLUS            reduce using rule 95 (exp4 -> exp5 .)
    MINUS           reduce using rule 95 (exp4 -> exp5 .)
    EQUAL           reduce using rule 95 (exp4 -> exp5 .)
    NOTEQUAL        reduce using rule 95 (exp4 -> exp5 .)
    LESSTHAN        reduce using rule 95 (exp4 -> exp5 .)
    LEQ             reduce using rule 95 (exp4 -> exp5 .)
    GREATERTHAN     reduce using rule 95 (exp4 -> exp5 .)
    GEQ             reduce using rule 95 (exp4 -> exp5 .)
    AND             reduce using rule 95 (exp4 -> exp5 .)
    OR              reduce using rule 95 (exp4 -> exp5 .)
    DOUBLECOLON     reduce using rule 95 (exp4 -> exp5 .)
    SEMICOLON       reduce using rule 95 (exp4 -> exp5 .)
    RPAREN          reduce using rule 95 (exp4 -> exp5 .)
    COMMA           reduce using rule 95 (exp4 -> exp5 .)
    RBRACE          reduce using rule 95 (exp4 -> exp5 .)
    RBRACKET        reduce using rule 95 (exp4 -> exp5 .)


state 29

    (105) exp6 -> MINUS . exp6
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp6                           shift and go to state 70
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 30

    (102) exp5 -> exp6 .
    MUL             reduce using rule 102 (exp5 -> exp6 .)
    DIV             reduce using rule 102 (exp5 -> exp6 .)
    MOD             reduce using rule 102 (exp5 -> exp6 .)
    PLUS            reduce using rule 102 (exp5 -> exp6 .)
    MINUS           reduce using rule 102 (exp5 -> exp6 .)
    EQUAL           reduce using rule 102 (exp5 -> exp6 .)
    NOTEQUAL        reduce using rule 102 (exp5 -> exp6 .)
    LESSTHAN        reduce using rule 102 (exp5 -> exp6 .)
    LEQ             reduce using rule 102 (exp5 -> exp6 .)
    GREATERTHAN     reduce using rule 102 (exp5 -> exp6 .)
    GEQ             reduce using rule 102 (exp5 -> exp6 .)
    AND             reduce using rule 102 (exp5 -> exp6 .)
    OR              reduce using rule 102 (exp5 -> exp6 .)
    DOUBLECOLON     reduce using rule 102 (exp5 -> exp6 .)
    SEMICOLON       reduce using rule 102 (exp5 -> exp6 .)
    RPAREN          reduce using rule 102 (exp5 -> exp6 .)
    COMMA           reduce using rule 102 (exp5 -> exp6 .)
    RBRACE          reduce using rule 102 (exp5 -> exp6 .)
    RBRACKET        reduce using rule 102 (exp5 -> exp6 .)


state 31

    (103) exp5 -> NOT . exp5
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp5                           shift and go to state 71
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 32

    (104) exp6 -> exp7 .
    MUL             reduce using rule 104 (exp6 -> exp7 .)
    DIV             reduce using rule 104 (exp6 -> exp7 .)
    MOD             reduce using rule 104 (exp6 -> exp7 .)
    PLUS            reduce using rule 104 (exp6 -> exp7 .)
    MINUS           reduce using rule 104 (exp6 -> exp7 .)
    EQUAL           reduce using rule 104 (exp6 -> exp7 .)
    NOTEQUAL        reduce using rule 104 (exp6 -> exp7 .)
    LESSTHAN        reduce using rule 104 (exp6 -> exp7 .)
    LEQ             reduce using rule 104 (exp6 -> exp7 .)
    GREATERTHAN     reduce using rule 104 (exp6 -> exp7 .)
    GEQ             reduce using rule 104 (exp6 -> exp7 .)
    AND             reduce using rule 104 (exp6 -> exp7 .)
    OR              reduce using rule 104 (exp6 -> exp7 .)
    DOUBLECOLON     reduce using rule 104 (exp6 -> exp7 .)
    SEMICOLON       reduce using rule 104 (exp6 -> exp7 .)
    RPAREN          reduce using rule 104 (exp6 -> exp7 .)
    COMMA           reduce using rule 104 (exp6 -> exp7 .)
    RBRACE          reduce using rule 104 (exp6 -> exp7 .)
    RBRACKET        reduce using rule 104 (exp6 -> exp7 .)


state 33

    (106) exp7 -> exp8 .
    MUL             reduce using rule 106 (exp7 -> exp8 .)
    DIV             reduce using rule 106 (exp7 -> exp8 .)
    MOD             reduce using rule 106 (exp7 -> exp8 .)
    PLUS            reduce using rule 106 (exp7 -> exp8 .)
    MINUS           reduce using rule 106 (exp7 -> exp8 .)
    EQUAL           reduce using rule 106 (exp7 -> exp8 .)
    NOTEQUAL        reduce using rule 106 (exp7 -> exp8 .)
    LESSTHAN        reduce using rule 106 (exp7 -> exp8 .)
    LEQ             reduce using rule 106 (exp7 -> exp8 .)
    GREATERTHAN     reduce using rule 106 (exp7 -> exp8 .)
    GEQ             reduce using rule 106 (exp7 -> exp8 .)
    AND             reduce using rule 106 (exp7 -> exp8 .)
    OR              reduce using rule 106 (exp7 -> exp8 .)
    DOUBLECOLON     reduce using rule 106 (exp7 -> exp8 .)
    SEMICOLON       reduce using rule 106 (exp7 -> exp8 .)
    RPAREN          reduce using rule 106 (exp7 -> exp8 .)
    COMMA           reduce using rule 106 (exp7 -> exp8 .)
    RBRACE          reduce using rule 106 (exp7 -> exp8 .)
    RBRACKET        reduce using rule 106 (exp7 -> exp8 .)


state 34

    (108) exp8 -> exp9 .
    MUL             reduce using rule 108 (exp8 -> exp9 .)
    DIV             reduce using rule 108 (exp8 -> exp9 .)
    MOD             reduce using rule 108 (exp8 -> exp9 .)
    PLUS            reduce using rule 108 (exp8 -> exp9 .)
    MINUS           reduce using rule 108 (exp8 -> exp9 .)
    EQUAL           reduce using rule 108 (exp8 -> exp9 .)
    NOTEQUAL        reduce using rule 108 (exp8 -> exp9 .)
    LESSTHAN        reduce using rule 108 (exp8 -> exp9 .)
    LEQ             reduce using rule 108 (exp8 -> exp9 .)
    GREATERTHAN     reduce using rule 108 (exp8 -> exp9 .)
    GEQ             reduce using rule 108 (exp8 -> exp9 .)
    AND             reduce using rule 108 (exp8 -> exp9 .)
    OR              reduce using rule 108 (exp8 -> exp9 .)
    DOUBLECOLON     reduce using rule 108 (exp8 -> exp9 .)
    SEMICOLON       reduce using rule 108 (exp8 -> exp9 .)
    RPAREN          reduce using rule 108 (exp8 -> exp9 .)
    COMMA           reduce using rule 108 (exp8 -> exp9 .)
    RBRACE          reduce using rule 108 (exp8 -> exp9 .)
    RBRACKET        reduce using rule 108 (exp8 -> exp9 .)


state 35

    (109) exp8 -> funcall .
    MUL             reduce using rule 109 (exp8 -> funcall .)
    DIV             reduce using rule 109 (exp8 -> funcall .)
    MOD             reduce using rule 109 (exp8 -> funcall .)
    PLUS            reduce using rule 109 (exp8 -> funcall .)
    MINUS           reduce using rule 109 (exp8 -> funcall .)
    EQUAL           reduce using rule 109 (exp8 -> funcall .)
    NOTEQUAL        reduce using rule 109 (exp8 -> funcall .)
    LESSTHAN        reduce using rule 109 (exp8 -> funcall .)
    LEQ             reduce using rule 109 (exp8 -> funcall .)
    GREATERTHAN     reduce using rule 109 (exp8 -> funcall .)
    GEQ             reduce using rule 109 (exp8 -> funcall .)
    AND             reduce using rule 109 (exp8 -> funcall .)
    OR              reduce using rule 109 (exp8 -> funcall .)
    DOUBLECOLON     reduce using rule 109 (exp8 -> funcall .)
    SEMICOLON       reduce using rule 109 (exp8 -> funcall .)
    RPAREN          reduce using rule 109 (exp8 -> funcall .)
    COMMA           reduce using rule 109 (exp8 -> funcall .)
    RBRACE          reduce using rule 109 (exp8 -> funcall .)
    RBRACKET        reduce using rule 109 (exp8 -> funcall .)


state 36

    (110) exp9 -> exp10 .
    MUL             reduce using rule 110 (exp9 -> exp10 .)
    DIV             reduce using rule 110 (exp9 -> exp10 .)
    MOD             reduce using rule 110 (exp9 -> exp10 .)
    PLUS            reduce using rule 110 (exp9 -> exp10 .)
    MINUS           reduce using rule 110 (exp9 -> exp10 .)
    EQUAL           reduce using rule 110 (exp9 -> exp10 .)
    NOTEQUAL        reduce using rule 110 (exp9 -> exp10 .)
    LESSTHAN        reduce using rule 110 (exp9 -> exp10 .)
    LEQ             reduce using rule 110 (exp9 -> exp10 .)
    GREATERTHAN     reduce using rule 110 (exp9 -> exp10 .)
    GEQ             reduce using rule 110 (exp9 -> exp10 .)
    AND             reduce using rule 110 (exp9 -> exp10 .)
    OR              reduce using rule 110 (exp9 -> exp10 .)
    DOUBLECOLON     reduce using rule 110 (exp9 -> exp10 .)
    SEMICOLON       reduce using rule 110 (exp9 -> exp10 .)
    RPAREN          reduce using rule 110 (exp9 -> exp10 .)
    COMMA           reduce using rule 110 (exp9 -> exp10 .)
    RBRACE          reduce using rule 110 (exp9 -> exp10 .)
    RBRACKET        reduce using rule 110 (exp9 -> exp10 .)


state 37

    (111) exp9 -> arraylit .
    MUL             reduce using rule 111 (exp9 -> arraylit .)
    DIV             reduce using rule 111 (exp9 -> arraylit .)
    MOD             reduce using rule 111 (exp9 -> arraylit .)
    PLUS            reduce using rule 111 (exp9 -> arraylit .)
    MINUS           reduce using rule 111 (exp9 -> arraylit .)
    EQUAL           reduce using rule 111 (exp9 -> arraylit .)
    NOTEQUAL        reduce using rule 111 (exp9 -> arraylit .)
    LESSTHAN        reduce using rule 111 (exp9 -> arraylit .)
    LEQ             reduce using rule 111 (exp9 -> arraylit .)
    GREATERTHAN     reduce using rule 111 (exp9 -> arraylit .)
    GEQ             reduce using rule 111 (exp9 -> arraylit .)
    AND             reduce using rule 111 (exp9 -> arraylit .)
    OR              reduce using rule 111 (exp9 -> arraylit .)
    DOUBLECOLON     reduce using rule 111 (exp9 -> arraylit .)
    SEMICOLON       reduce using rule 111 (exp9 -> arraylit .)
    RPAREN          reduce using rule 111 (exp9 -> arraylit .)
    COMMA           reduce using rule 111 (exp9 -> arraylit .)
    RBRACE          reduce using rule 111 (exp9 -> arraylit .)
    RBRACKET        reduce using rule 111 (exp9 -> arraylit .)


state 38

    (113) exp9 -> STRINGLIT .
    MUL             reduce using rule 113 (exp9 -> STRINGLIT .)
    DIV             reduce using rule 113 (exp9 -> STRINGLIT .)
    MOD             reduce using rule 113 (exp9 -> STRINGLIT .)
    PLUS            reduce using rule 113 (exp9 -> STRINGLIT .)
    MINUS           reduce using rule 113 (exp9 -> STRINGLIT .)
    EQUAL           reduce using rule 113 (exp9 -> STRINGLIT .)
    NOTEQUAL        reduce using rule 113 (exp9 -> STRINGLIT .)
    LESSTHAN        reduce using rule 113 (exp9 -> STRINGLIT .)
    LEQ             reduce using rule 113 (exp9 -> STRINGLIT .)
    GREATERTHAN     reduce using rule 113 (exp9 -> STRINGLIT .)
    GEQ             reduce using rule 113 (exp9 -> STRINGLIT .)
    AND             reduce using rule 113 (exp9 -> STRINGLIT .)
    OR              reduce using rule 113 (exp9 -> STRINGLIT .)
    DOUBLECOLON     reduce using rule 113 (exp9 -> STRINGLIT .)
    SEMICOLON       reduce using rule 113 (exp9 -> STRINGLIT .)
    RPAREN          reduce using rule 113 (exp9 -> STRINGLIT .)
    COMMA           reduce using rule 113 (exp9 -> STRINGLIT .)
    RBRACE          reduce using rule 113 (exp9 -> STRINGLIT .)
    RBRACKET        reduce using rule 113 (exp9 -> STRINGLIT .)


state 39

    (114) exp9 -> BOOLEANLIT .
    MUL             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    DIV             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    MOD             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    PLUS            reduce using rule 114 (exp9 -> BOOLEANLIT .)
    MINUS           reduce using rule 114 (exp9 -> BOOLEANLIT .)
    EQUAL           reduce using rule 114 (exp9 -> BOOLEANLIT .)
    NOTEQUAL        reduce using rule 114 (exp9 -> BOOLEANLIT .)
    LESSTHAN        reduce using rule 114 (exp9 -> BOOLEANLIT .)
    LEQ             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    GREATERTHAN     reduce using rule 114 (exp9 -> BOOLEANLIT .)
    GEQ             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    AND             reduce using rule 114 (exp9 -> BOOLEANLIT .)
    OR              reduce using rule 114 (exp9 -> BOOLEANLIT .)
    DOUBLECOLON     reduce using rule 114 (exp9 -> BOOLEANLIT .)
    SEMICOLON       reduce using rule 114 (exp9 -> BOOLEANLIT .)
    RPAREN          reduce using rule 114 (exp9 -> BOOLEANLIT .)
    COMMA           reduce using rule 114 (exp9 -> BOOLEANLIT .)
    RBRACE          reduce using rule 114 (exp9 -> BOOLEANLIT .)
    RBRACKET        reduce using rule 114 (exp9 -> BOOLEANLIT .)


state 40

    (115) exp9 -> FLOATLIT .
    MUL             reduce using rule 115 (exp9 -> FLOATLIT .)
    DIV             reduce using rule 115 (exp9 -> FLOATLIT .)
    MOD             reduce using rule 115 (exp9 -> FLOATLIT .)
    PLUS            reduce using rule 115 (exp9 -> FLOATLIT .)
    MINUS           reduce using rule 115 (exp9 -> FLOATLIT .)
    EQUAL           reduce using rule 115 (exp9 -> FLOATLIT .)
    NOTEQUAL        reduce using rule 115 (exp9 -> FLOATLIT .)
    LESSTHAN        reduce using rule 115 (exp9 -> FLOATLIT .)
    LEQ             reduce using rule 115 (exp9 -> FLOATLIT .)
    GREATERTHAN     reduce using rule 115 (exp9 -> FLOATLIT .)
    GEQ             reduce using rule 115 (exp9 -> FLOATLIT .)
    AND             reduce using rule 115 (exp9 -> FLOATLIT .)
    OR              reduce using rule 115 (exp9 -> FLOATLIT .)
    DOUBLECOLON     reduce using rule 115 (exp9 -> FLOATLIT .)
    SEMICOLON       reduce using rule 115 (exp9 -> FLOATLIT .)
    RPAREN          reduce using rule 115 (exp9 -> FLOATLIT .)
    COMMA           reduce using rule 115 (exp9 -> FLOATLIT .)
    RBRACE          reduce using rule 115 (exp9 -> FLOATLIT .)
    RBRACKET        reduce using rule 115 (exp9 -> FLOATLIT .)


state 41

    (116) exp9 -> INTLIT .
    MUL             reduce using rule 116 (exp9 -> INTLIT .)
    DIV             reduce using rule 116 (exp9 -> INTLIT .)
    MOD             reduce using rule 116 (exp9 -> INTLIT .)
    PLUS            reduce using rule 116 (exp9 -> INTLIT .)
    MINUS           reduce using rule 116 (exp9 -> INTLIT .)
    EQUAL           reduce using rule 116 (exp9 -> INTLIT .)
    NOTEQUAL        reduce using rule 116 (exp9 -> INTLIT .)
    LESSTHAN        reduce using rule 116 (exp9 -> INTLIT .)
    LEQ             reduce using rule 116 (exp9 -> INTLIT .)
    GREATERTHAN     reduce using rule 116 (exp9 -> INTLIT .)
    GEQ             reduce using rule 116 (exp9 -> INTLIT .)
    AND             reduce using rule 116 (exp9 -> INTLIT .)
    OR              reduce using rule 116 (exp9 -> INTLIT .)
    DOUBLECOLON     reduce using rule 116 (exp9 -> INTLIT .)
    SEMICOLON       reduce using rule 116 (exp9 -> INTLIT .)
    RPAREN          reduce using rule 116 (exp9 -> INTLIT .)
    COMMA           reduce using rule 116 (exp9 -> INTLIT .)
    RBRACE          reduce using rule 116 (exp9 -> INTLIT .)
    RBRACKET        reduce using rule 116 (exp9 -> INTLIT .)


state 42

    (117) exp10 -> LPAREN . exp0 RPAREN
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 72
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 43

    (78) arraylit -> LBRACE . explist RBRACE
    (79) explist -> . empty
    (80) explist -> . expprime
    (118) empty -> .
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    RBRACE          reduce using rule 118 (empty -> .)
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    explist                        shift and go to state 73
    empty                          shift and go to state 74
    expprime                       shift and go to state 75
    exp0                           shift and go to state 76
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 44

    (10) subvardecl -> COMMA ID . subvardecl exp0 COMMA
    (11) subvardecl2 -> COMMA ID . subvardecl3
    (9) subvardecl -> . COLON typeof ASSIGNMENT
    (10) subvardecl -> . COMMA ID subvardecl exp0 COMMA
    (12) subvardecl3 -> . COLON typeof SEMICOLON
    COLON           shift and go to state 80
    COMMA           shift and go to state 77

    subvardecl                     shift and go to state 78
    subvardecl3                    shift and go to state 79

state 45

    (29) funcdecl -> ID COLON FUNCTION returntype . paramdecl INHERIT ID blockstmt
    (30) funcdecl -> ID COLON FUNCTION returntype . paramdecl blockstmt
    (31) paramdecl -> . LPAREN paramlist RPAREN
    LPAREN          shift and go to state 82

    paramdecl                      shift and go to state 81

state 46

    (25) returntype -> arrtype .
    LPAREN          reduce using rule 25 (returntype -> arrtype .)


state 47

    (26) returntype -> atotype .
    LPAREN          reduce using rule 26 (returntype -> atotype .)


state 48

    (27) returntype -> VOID .
    LPAREN          reduce using rule 27 (returntype -> VOID .)


state 49

    (28) returntype -> AUTO .
    LPAREN          reduce using rule 28 (returntype -> AUTO .)


state 50

    (8) vardecl -> ID COLON typeof SEMICOLON .
    ID              reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    $end            reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    IF              reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    LBRACE          reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    RETURN          reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    CONTINUE        reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    BREAK           reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    DO              reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    WHILE           reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    FOR             reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)
    RBRACE          reduce using rule 8 (vardecl -> ID COLON typeof SEMICOLON .)


state 51

    (9) subvardecl -> COLON typeof ASSIGNMENT .
    NOT             reduce using rule 9 (subvardecl -> COLON typeof ASSIGNMENT .)
    MINUS           reduce using rule 9 (subvardecl -> COLON typeof ASSIGNMENT .)
    ID              reduce using rule 9 (subvardecl -> COLON typeof ASSIGNMENT .)
    STRINGLIT       reduce using rule 9 (subvardecl -> COLON typeof ASSIGNMENT .)
    BOOLEANLIT      reduce using rule 9 (subvardecl -> COLON typeof ASSIGNMENT .)
    FLOATLIT        reduce using rule 9 (subvardecl -> COLON typeof ASSIGNMENT .)
    INTLIT          reduce using rule 9 (subvardecl -> COLON typeof ASSIGNMENT .)
    LPAREN          reduce using rule 9 (subvardecl -> COLON typeof ASSIGNMENT .)
    LBRACE          reduce using rule 9 (subvardecl -> COLON typeof ASSIGNMENT .)


state 52

    (22) arrtype -> ARRAY LBRACKET . dime RBRACKET OF atotype
    (23) dime -> . INTLIT
    (24) dime -> . INTLIT COMMA dime
    INTLIT          shift and go to state 84

    dime                           shift and go to state 83

state 53

    (107) exp7 -> ID LBRACKET . expprime RBRACKET
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    expprime                       shift and go to state 85
    exp0                           shift and go to state 76
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 54

    (77) funcall -> ID LPAREN . explist RPAREN
    (79) explist -> . empty
    (80) explist -> . expprime
    (118) empty -> .
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    RPAREN          reduce using rule 118 (empty -> .)
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    explist                        shift and go to state 86
    empty                          shift and go to state 74
    expprime                       shift and go to state 75
    exp0                           shift and go to state 76
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 55

    (6) vardecl -> ID subvardecl exp0 SEMICOLON .
    ID              reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    $end            reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    IF              reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    LBRACE          reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    RETURN          reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    CONTINUE        reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    BREAK           reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    DO              reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    WHILE           reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    FOR             reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)
    RBRACE          reduce using rule 6 (vardecl -> ID subvardecl exp0 SEMICOLON .)


state 56

    (90) exp1 -> exp1 DOUBLECOLON . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp1                           shift and go to state 87
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 57

    (84) exp1 -> exp2 EQUAL . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp2                           shift and go to state 88
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 58

    (85) exp1 -> exp2 NOTEQUAL . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp2                           shift and go to state 89
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 59

    (86) exp1 -> exp2 LESSTHAN . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp2                           shift and go to state 90
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 60

    (87) exp1 -> exp2 LEQ . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp2                           shift and go to state 91
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 61

    (88) exp1 -> exp2 GREATERTHAN . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp2                           shift and go to state 92
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 62

    (89) exp1 -> exp2 GEQ . exp2
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp2                           shift and go to state 93
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 63

    (93) exp2 -> exp2 AND . exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp3                           shift and go to state 94
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 64

    (94) exp2 -> exp2 OR . exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp3                           shift and go to state 95
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 65

    (99) exp4 -> exp3 PLUS . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (101) exp3 -> . exp4
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp3                           shift and go to state 96
    exp4                           shift and go to state 97
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 66

    (100) exp4 -> exp3 MINUS . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (101) exp3 -> . exp4
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp3                           shift and go to state 96
    exp4                           shift and go to state 98
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 67

    (96) exp4 -> exp4 MUL . exp5
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp5                           shift and go to state 99
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 68

    (97) exp4 -> exp4 DIV . exp5
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp5                           shift and go to state 100
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 69

    (98) exp4 -> exp4 MOD . exp5
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp5                           shift and go to state 101
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 70

    (105) exp6 -> MINUS exp6 .
    MUL             reduce using rule 105 (exp6 -> MINUS exp6 .)
    DIV             reduce using rule 105 (exp6 -> MINUS exp6 .)
    MOD             reduce using rule 105 (exp6 -> MINUS exp6 .)
    PLUS            reduce using rule 105 (exp6 -> MINUS exp6 .)
    MINUS           reduce using rule 105 (exp6 -> MINUS exp6 .)
    EQUAL           reduce using rule 105 (exp6 -> MINUS exp6 .)
    NOTEQUAL        reduce using rule 105 (exp6 -> MINUS exp6 .)
    LESSTHAN        reduce using rule 105 (exp6 -> MINUS exp6 .)
    LEQ             reduce using rule 105 (exp6 -> MINUS exp6 .)
    GREATERTHAN     reduce using rule 105 (exp6 -> MINUS exp6 .)
    GEQ             reduce using rule 105 (exp6 -> MINUS exp6 .)
    AND             reduce using rule 105 (exp6 -> MINUS exp6 .)
    OR              reduce using rule 105 (exp6 -> MINUS exp6 .)
    DOUBLECOLON     reduce using rule 105 (exp6 -> MINUS exp6 .)
    SEMICOLON       reduce using rule 105 (exp6 -> MINUS exp6 .)
    RPAREN          reduce using rule 105 (exp6 -> MINUS exp6 .)
    COMMA           reduce using rule 105 (exp6 -> MINUS exp6 .)
    RBRACE          reduce using rule 105 (exp6 -> MINUS exp6 .)
    RBRACKET        reduce using rule 105 (exp6 -> MINUS exp6 .)


state 71

    (103) exp5 -> NOT exp5 .
    MUL             reduce using rule 103 (exp5 -> NOT exp5 .)
    DIV             reduce using rule 103 (exp5 -> NOT exp5 .)
    MOD             reduce using rule 103 (exp5 -> NOT exp5 .)
    PLUS            reduce using rule 103 (exp5 -> NOT exp5 .)
    MINUS           reduce using rule 103 (exp5 -> NOT exp5 .)
    EQUAL           reduce using rule 103 (exp5 -> NOT exp5 .)
    NOTEQUAL        reduce using rule 103 (exp5 -> NOT exp5 .)
    LESSTHAN        reduce using rule 103 (exp5 -> NOT exp5 .)
    LEQ             reduce using rule 103 (exp5 -> NOT exp5 .)
    GREATERTHAN     reduce using rule 103 (exp5 -> NOT exp5 .)
    GEQ             reduce using rule 103 (exp5 -> NOT exp5 .)
    AND             reduce using rule 103 (exp5 -> NOT exp5 .)
    OR              reduce using rule 103 (exp5 -> NOT exp5 .)
    DOUBLECOLON     reduce using rule 103 (exp5 -> NOT exp5 .)
    SEMICOLON       reduce using rule 103 (exp5 -> NOT exp5 .)
    RPAREN          reduce using rule 103 (exp5 -> NOT exp5 .)
    COMMA           reduce using rule 103 (exp5 -> NOT exp5 .)
    RBRACE          reduce using rule 103 (exp5 -> NOT exp5 .)
    RBRACKET        reduce using rule 103 (exp5 -> NOT exp5 .)


state 72

    (117) exp10 -> LPAREN exp0 . RPAREN
    RPAREN          shift and go to state 102


state 73

    (78) arraylit -> LBRACE explist . RBRACE
    RBRACE          shift and go to state 103


state 74

    (79) explist -> empty .
    RBRACE          reduce using rule 79 (explist -> empty .)
    RPAREN          reduce using rule 79 (explist -> empty .)


state 75

    (80) explist -> expprime .
    RBRACE          reduce using rule 80 (explist -> expprime .)
    RPAREN          reduce using rule 80 (explist -> expprime .)


state 76

    (81) expprime -> exp0 .
    (82) expprime -> exp0 . COMMA expprime
    RBRACE          reduce using rule 81 (expprime -> exp0 .)
    RBRACKET        reduce using rule 81 (expprime -> exp0 .)
    RPAREN          reduce using rule 81 (expprime -> exp0 .)
    COMMA           shift and go to state 104


state 77

    (10) subvardecl -> COMMA . ID subvardecl exp0 COMMA
    ID              shift and go to state 105


state 78

    (10) subvardecl -> COMMA ID subvardecl . exp0 COMMA
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 106
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 79

    (11) subvardecl2 -> COMMA ID subvardecl3 .
    ID              reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    $end            reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    IF              reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    LBRACE          reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    RETURN          reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    CONTINUE        reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    BREAK           reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    DO              reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    WHILE           reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    FOR             reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)
    RBRACE          reduce using rule 11 (subvardecl2 -> COMMA ID subvardecl3 .)


state 80

    (9) subvardecl -> COLON . typeof ASSIGNMENT
    (12) subvardecl3 -> COLON . typeof SEMICOLON
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 16
    ARRAY           shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    typeof                         shift and go to state 107
    arrtype                        shift and go to state 14
    atotype                        shift and go to state 15

state 81

    (29) funcdecl -> ID COLON FUNCTION returntype paramdecl . INHERIT ID blockstmt
    (30) funcdecl -> ID COLON FUNCTION returntype paramdecl . blockstmt
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    INHERIT         shift and go to state 108
    LBRACE          shift and go to state 110

    blockstmt                      shift and go to state 109

state 82

    (31) paramdecl -> LPAREN . paramlist RPAREN
    (32) paramlist -> . empty
    (33) paramlist -> . paramprime
    (118) empty -> .
    (34) paramprime -> . param
    (35) paramprime -> . param COMMA paramprime
    (36) param -> . OUT ID COLON typeof
    (37) param -> . INHERIT ID COLON typeof
    (38) param -> . ID COLON typeof
    (39) param -> . INHERIT OUT ID COLON typeof
    RPAREN          reduce using rule 118 (empty -> .)
    OUT             shift and go to state 115
    INHERIT         shift and go to state 117
    ID              shift and go to state 116

    paramlist                      shift and go to state 111
    empty                          shift and go to state 112
    paramprime                     shift and go to state 113
    param                          shift and go to state 114

state 83

    (22) arrtype -> ARRAY LBRACKET dime . RBRACKET OF atotype
    RBRACKET        shift and go to state 118


state 84

    (23) dime -> INTLIT .
    (24) dime -> INTLIT . COMMA dime
    RBRACKET        reduce using rule 23 (dime -> INTLIT .)
    COMMA           shift and go to state 119


state 85

    (107) exp7 -> ID LBRACKET expprime . RBRACKET
    RBRACKET        shift and go to state 120


state 86

    (77) funcall -> ID LPAREN explist . RPAREN
    RPAREN          shift and go to state 121


state 87

    (90) exp1 -> exp1 DOUBLECOLON exp1 .
    (90) exp1 -> exp1 . DOUBLECOLON exp1
  ! shift/reduce conflict for DOUBLECOLON resolved as shift
    SEMICOLON       reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    RPAREN          reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    COMMA           reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    RBRACE          reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    RBRACKET        reduce using rule 90 (exp1 -> exp1 DOUBLECOLON exp1 .)
    DOUBLECOLON     shift and go to state 56


state 88

    (84) exp1 -> exp2 EQUAL exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    SEMICOLON       reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    RPAREN          reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    COMMA           reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    RBRACE          reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    RBRACKET        reduce using rule 84 (exp1 -> exp2 EQUAL exp2 .)
    AND             shift and go to state 63
    OR              shift and go to state 64


state 89

    (85) exp1 -> exp2 NOTEQUAL exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    SEMICOLON       reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    RPAREN          reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    COMMA           reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    RBRACE          reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    RBRACKET        reduce using rule 85 (exp1 -> exp2 NOTEQUAL exp2 .)
    AND             shift and go to state 63
    OR              shift and go to state 64


state 90

    (86) exp1 -> exp2 LESSTHAN exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    SEMICOLON       reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    RPAREN          reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    COMMA           reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    RBRACE          reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    RBRACKET        reduce using rule 86 (exp1 -> exp2 LESSTHAN exp2 .)
    AND             shift and go to state 63
    OR              shift and go to state 64


state 91

    (87) exp1 -> exp2 LEQ exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    SEMICOLON       reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    RPAREN          reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    COMMA           reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    RBRACE          reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    RBRACKET        reduce using rule 87 (exp1 -> exp2 LEQ exp2 .)
    AND             shift and go to state 63
    OR              shift and go to state 64


state 92

    (88) exp1 -> exp2 GREATERTHAN exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    SEMICOLON       reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    RPAREN          reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    COMMA           reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    RBRACE          reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    RBRACKET        reduce using rule 88 (exp1 -> exp2 GREATERTHAN exp2 .)
    AND             shift and go to state 63
    OR              shift and go to state 64


state 93

    (89) exp1 -> exp2 GEQ exp2 .
    (93) exp2 -> exp2 . AND exp3
    (94) exp2 -> exp2 . OR exp3
    DOUBLECOLON     reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    SEMICOLON       reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    RPAREN          reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    COMMA           reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    RBRACE          reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    RBRACKET        reduce using rule 89 (exp1 -> exp2 GEQ exp2 .)
    AND             shift and go to state 63
    OR              shift and go to state 64


state 94

    (93) exp2 -> exp2 AND exp3 .
    (99) exp4 -> exp3 . PLUS exp4
    (100) exp4 -> exp3 . MINUS exp4
    EQUAL           reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    NOTEQUAL        reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    LESSTHAN        reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    LEQ             reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    GREATERTHAN     reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    GEQ             reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    AND             reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    OR              reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    DOUBLECOLON     reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    SEMICOLON       reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    RPAREN          reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    COMMA           reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    RBRACE          reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    RBRACKET        reduce using rule 93 (exp2 -> exp2 AND exp3 .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 95

    (94) exp2 -> exp2 OR exp3 .
    (99) exp4 -> exp3 . PLUS exp4
    (100) exp4 -> exp3 . MINUS exp4
    EQUAL           reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    NOTEQUAL        reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    LESSTHAN        reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    LEQ             reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    GREATERTHAN     reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    GEQ             reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    AND             reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    OR              reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    DOUBLECOLON     reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    SEMICOLON       reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    RPAREN          reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    COMMA           reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    RBRACE          reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    RBRACKET        reduce using rule 94 (exp2 -> exp2 OR exp3 .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 96

    (99) exp4 -> exp3 . PLUS exp4
    (100) exp4 -> exp3 . MINUS exp4
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 97

    (99) exp4 -> exp3 PLUS exp4 .
    (96) exp4 -> exp4 . MUL exp5
    (97) exp4 -> exp4 . DIV exp5
    (98) exp4 -> exp4 . MOD exp5
    (101) exp3 -> exp4 .
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 99 (exp4 -> exp3 PLUS exp4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 99 (exp4 -> exp3 PLUS exp4 .)
    PLUS            reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    MINUS           reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    EQUAL           reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    NOTEQUAL        reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    LESSTHAN        reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    LEQ             reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    GREATERTHAN     reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    GEQ             reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    AND             reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    OR              reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    DOUBLECOLON     reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    SEMICOLON       reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    RPAREN          reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    COMMA           reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    RBRACE          reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    RBRACKET        reduce using rule 99 (exp4 -> exp3 PLUS exp4 .)
    MUL             shift and go to state 67
    DIV             shift and go to state 68
    MOD             shift and go to state 69


state 98

    (100) exp4 -> exp3 MINUS exp4 .
    (96) exp4 -> exp4 . MUL exp5
    (97) exp4 -> exp4 . DIV exp5
    (98) exp4 -> exp4 . MOD exp5
    (101) exp3 -> exp4 .
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 100 (exp4 -> exp3 MINUS exp4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 100 (exp4 -> exp3 MINUS exp4 .)
    PLUS            reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    MINUS           reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    EQUAL           reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    NOTEQUAL        reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    LESSTHAN        reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    LEQ             reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    GREATERTHAN     reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    GEQ             reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    AND             reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    OR              reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    DOUBLECOLON     reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    SEMICOLON       reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    RPAREN          reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    COMMA           reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    RBRACE          reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    RBRACKET        reduce using rule 100 (exp4 -> exp3 MINUS exp4 .)
    MUL             shift and go to state 67
    DIV             shift and go to state 68
    MOD             shift and go to state 69


state 99

    (96) exp4 -> exp4 MUL exp5 .
    MUL             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    DIV             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    MOD             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    PLUS            reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    MINUS           reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    EQUAL           reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    NOTEQUAL        reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    LESSTHAN        reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    LEQ             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    GREATERTHAN     reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    GEQ             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    AND             reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    OR              reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    DOUBLECOLON     reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    SEMICOLON       reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    RPAREN          reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    COMMA           reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    RBRACE          reduce using rule 96 (exp4 -> exp4 MUL exp5 .)
    RBRACKET        reduce using rule 96 (exp4 -> exp4 MUL exp5 .)


state 100

    (97) exp4 -> exp4 DIV exp5 .
    MUL             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    DIV             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    MOD             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    PLUS            reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    MINUS           reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    EQUAL           reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    NOTEQUAL        reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    LESSTHAN        reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    LEQ             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    GREATERTHAN     reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    GEQ             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    AND             reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    OR              reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    DOUBLECOLON     reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    SEMICOLON       reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    RPAREN          reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    COMMA           reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    RBRACE          reduce using rule 97 (exp4 -> exp4 DIV exp5 .)
    RBRACKET        reduce using rule 97 (exp4 -> exp4 DIV exp5 .)


state 101

    (98) exp4 -> exp4 MOD exp5 .
    MUL             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    DIV             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    MOD             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    PLUS            reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    MINUS           reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    EQUAL           reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    NOTEQUAL        reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    LESSTHAN        reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    LEQ             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    GREATERTHAN     reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    GEQ             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    AND             reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    OR              reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    DOUBLECOLON     reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    SEMICOLON       reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    RPAREN          reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    COMMA           reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    RBRACE          reduce using rule 98 (exp4 -> exp4 MOD exp5 .)
    RBRACKET        reduce using rule 98 (exp4 -> exp4 MOD exp5 .)


state 102

    (117) exp10 -> LPAREN exp0 RPAREN .
    MUL             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    DIV             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    MOD             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    PLUS            reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    MINUS           reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    EQUAL           reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    NOTEQUAL        reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    LESSTHAN        reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    LEQ             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    GREATERTHAN     reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    GEQ             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    AND             reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    OR              reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    DOUBLECOLON     reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    SEMICOLON       reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    RPAREN          reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    COMMA           reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    RBRACE          reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)
    RBRACKET        reduce using rule 117 (exp10 -> LPAREN exp0 RPAREN .)


state 103

    (78) arraylit -> LBRACE explist RBRACE .
    MUL             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    DIV             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    MOD             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    PLUS            reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    MINUS           reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    EQUAL           reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    NOTEQUAL        reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    LESSTHAN        reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    LEQ             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    GREATERTHAN     reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    GEQ             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    AND             reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    OR              reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    DOUBLECOLON     reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    SEMICOLON       reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    RPAREN          reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    COMMA           reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    RBRACE          reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)
    RBRACKET        reduce using rule 78 (arraylit -> LBRACE explist RBRACE .)


state 104

    (82) expprime -> exp0 COMMA . expprime
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 76
    expprime                       shift and go to state 122
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 105

    (10) subvardecl -> COMMA ID . subvardecl exp0 COMMA
    (9) subvardecl -> . COLON typeof ASSIGNMENT
    (10) subvardecl -> . COMMA ID subvardecl exp0 COMMA
    COLON           shift and go to state 123
    COMMA           shift and go to state 77

    subvardecl                     shift and go to state 78

state 106

    (10) subvardecl -> COMMA ID subvardecl exp0 . COMMA
    COMMA           shift and go to state 124


state 107

    (9) subvardecl -> COLON typeof . ASSIGNMENT
    (12) subvardecl3 -> COLON typeof . SEMICOLON
    ASSIGNMENT      shift and go to state 51
    SEMICOLON       shift and go to state 125


state 108

    (29) funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT . ID blockstmt
    ID              shift and go to state 126


state 109

    (30) funcdecl -> ID COLON FUNCTION returntype paramdecl blockstmt .
    ID              reduce using rule 30 (funcdecl -> ID COLON FUNCTION returntype paramdecl blockstmt .)
    $end            reduce using rule 30 (funcdecl -> ID COLON FUNCTION returntype paramdecl blockstmt .)


state 110

    (76) blockstmt -> LBRACE . stmtlist RBRACE
    (40) stmtlist -> . empty
    (41) stmtlist -> . stmtprime
    (118) empty -> .
    (42) stmtprime -> . stmt
    (43) stmtprime -> . vardecl
    (44) stmtprime -> . vardecl stmtlist
    (45) stmtprime -> . stmt stmtlist
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl2
    (8) vardecl -> . ID COLON typeof SEMICOLON
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    RBRACE          reduce using rule 118 (empty -> .)
    ID              shift and go to state 134
    IF              shift and go to state 145
    LBRACE          shift and go to state 110
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    DO              shift and go to state 149
    WHILE           shift and go to state 150
    FOR             shift and go to state 151

    stmtlist                       shift and go to state 127
    empty                          shift and go to state 128
    stmtprime                      shift and go to state 129
    stmt                           shift and go to state 130
    vardecl                        shift and go to state 131
    matchstmt                      shift and go to state 132
    unmatchif                      shift and go to state 133
    blockstmt                      shift and go to state 135
    callstmt                       shift and go to state 136
    retstmt                        shift and go to state 137
    contistmt                      shift and go to state 138
    breakstmt                      shift and go to state 139
    dowhilestmt                    shift and go to state 140
    whilestmt                      shift and go to state 141
    forstmt                        shift and go to state 142
    matchif                        shift and go to state 143
    assigstmt                      shift and go to state 144

state 111

    (31) paramdecl -> LPAREN paramlist . RPAREN
    RPAREN          shift and go to state 152


state 112

    (32) paramlist -> empty .
    RPAREN          reduce using rule 32 (paramlist -> empty .)


state 113

    (33) paramlist -> paramprime .
    RPAREN          reduce using rule 33 (paramlist -> paramprime .)


state 114

    (34) paramprime -> param .
    (35) paramprime -> param . COMMA paramprime
    RPAREN          reduce using rule 34 (paramprime -> param .)
    COMMA           shift and go to state 153


state 115

    (36) param -> OUT . ID COLON typeof
    ID              shift and go to state 154


state 116

    (38) param -> ID . COLON typeof
    COLON           shift and go to state 155


state 117

    (37) param -> INHERIT . ID COLON typeof
    (39) param -> INHERIT . OUT ID COLON typeof
    ID              shift and go to state 156
    OUT             shift and go to state 157


state 118

    (22) arrtype -> ARRAY LBRACKET dime RBRACKET . OF atotype
    OF              shift and go to state 158


state 119

    (24) dime -> INTLIT COMMA . dime
    (23) dime -> . INTLIT
    (24) dime -> . INTLIT COMMA dime
    INTLIT          shift and go to state 84

    dime                           shift and go to state 159

state 120

    (107) exp7 -> ID LBRACKET expprime RBRACKET .
    MUL             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    DIV             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    MOD             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    PLUS            reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    MINUS           reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    EQUAL           reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    NOTEQUAL        reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    LESSTHAN        reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    LEQ             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    GREATERTHAN     reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    GEQ             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    AND             reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    OR              reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    DOUBLECOLON     reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    SEMICOLON       reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    RPAREN          reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    COMMA           reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    RBRACE          reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)
    RBRACKET        reduce using rule 107 (exp7 -> ID LBRACKET expprime RBRACKET .)


state 121

    (77) funcall -> ID LPAREN explist RPAREN .
    MUL             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    DIV             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    MOD             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    PLUS            reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    MINUS           reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    EQUAL           reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    NOTEQUAL        reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    LESSTHAN        reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    LEQ             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    GREATERTHAN     reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    GEQ             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    AND             reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    OR              reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    DOUBLECOLON     reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    SEMICOLON       reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    RPAREN          reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    COMMA           reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    RBRACE          reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)
    RBRACKET        reduce using rule 77 (funcall -> ID LPAREN explist RPAREN .)


state 122

    (82) expprime -> exp0 COMMA expprime .
    RBRACE          reduce using rule 82 (expprime -> exp0 COMMA expprime .)
    RBRACKET        reduce using rule 82 (expprime -> exp0 COMMA expprime .)
    RPAREN          reduce using rule 82 (expprime -> exp0 COMMA expprime .)


state 123

    (9) subvardecl -> COLON . typeof ASSIGNMENT
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 16
    ARRAY           shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    typeof                         shift and go to state 160
    arrtype                        shift and go to state 14
    atotype                        shift and go to state 15

state 124

    (10) subvardecl -> COMMA ID subvardecl exp0 COMMA .
    NOT             reduce using rule 10 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    MINUS           reduce using rule 10 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    ID              reduce using rule 10 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    STRINGLIT       reduce using rule 10 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    BOOLEANLIT      reduce using rule 10 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    FLOATLIT        reduce using rule 10 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    INTLIT          reduce using rule 10 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    LPAREN          reduce using rule 10 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)
    LBRACE          reduce using rule 10 (subvardecl -> COMMA ID subvardecl exp0 COMMA .)


state 125

    (12) subvardecl3 -> COLON typeof SEMICOLON .
    ID              reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    $end            reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    IF              reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    LBRACE          reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    RETURN          reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    CONTINUE        reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    BREAK           reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    DO              reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    WHILE           reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    FOR             reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)
    RBRACE          reduce using rule 12 (subvardecl3 -> COLON typeof SEMICOLON .)


state 126

    (29) funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID . blockstmt
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    LBRACE          shift and go to state 110

    blockstmt                      shift and go to state 161

state 127

    (76) blockstmt -> LBRACE stmtlist . RBRACE
    RBRACE          shift and go to state 162


state 128

    (40) stmtlist -> empty .
    RBRACE          reduce using rule 40 (stmtlist -> empty .)


state 129

    (41) stmtlist -> stmtprime .
    RBRACE          reduce using rule 41 (stmtlist -> stmtprime .)


state 130

    (42) stmtprime -> stmt .
    (45) stmtprime -> stmt . stmtlist
    (40) stmtlist -> . empty
    (41) stmtlist -> . stmtprime
    (118) empty -> .
    (42) stmtprime -> . stmt
    (43) stmtprime -> . vardecl
    (44) stmtprime -> . vardecl stmtlist
    (45) stmtprime -> . stmt stmtlist
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl2
    (8) vardecl -> . ID COLON typeof SEMICOLON
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
  ! reduce/reduce conflict for RBRACE resolved using rule 42 (stmtprime -> stmt .)
    RBRACE          reduce using rule 42 (stmtprime -> stmt .)
    ID              shift and go to state 134
    IF              shift and go to state 145
    LBRACE          shift and go to state 110
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    DO              shift and go to state 149
    WHILE           shift and go to state 150
    FOR             shift and go to state 151

    stmt                           shift and go to state 130
    stmtlist                       shift and go to state 163
    empty                          shift and go to state 128
    stmtprime                      shift and go to state 129
    vardecl                        shift and go to state 131
    matchstmt                      shift and go to state 132
    unmatchif                      shift and go to state 133
    blockstmt                      shift and go to state 135
    callstmt                       shift and go to state 136
    retstmt                        shift and go to state 137
    contistmt                      shift and go to state 138
    breakstmt                      shift and go to state 139
    dowhilestmt                    shift and go to state 140
    whilestmt                      shift and go to state 141
    forstmt                        shift and go to state 142
    matchif                        shift and go to state 143
    assigstmt                      shift and go to state 144

state 131

    (43) stmtprime -> vardecl .
    (44) stmtprime -> vardecl . stmtlist
    (40) stmtlist -> . empty
    (41) stmtlist -> . stmtprime
    (118) empty -> .
    (42) stmtprime -> . stmt
    (43) stmtprime -> . vardecl
    (44) stmtprime -> . vardecl stmtlist
    (45) stmtprime -> . stmt stmtlist
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (6) vardecl -> . ID subvardecl exp0 SEMICOLON
    (7) vardecl -> . ID subvardecl2
    (8) vardecl -> . ID COLON typeof SEMICOLON
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
  ! reduce/reduce conflict for RBRACE resolved using rule 43 (stmtprime -> vardecl .)
    RBRACE          reduce using rule 43 (stmtprime -> vardecl .)
    ID              shift and go to state 134
    IF              shift and go to state 145
    LBRACE          shift and go to state 110
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    DO              shift and go to state 149
    WHILE           shift and go to state 150
    FOR             shift and go to state 151

    vardecl                        shift and go to state 131
    stmtlist                       shift and go to state 164
    empty                          shift and go to state 128
    stmtprime                      shift and go to state 129
    stmt                           shift and go to state 130
    matchstmt                      shift and go to state 132
    unmatchif                      shift and go to state 133
    blockstmt                      shift and go to state 135
    callstmt                       shift and go to state 136
    retstmt                        shift and go to state 137
    contistmt                      shift and go to state 138
    breakstmt                      shift and go to state 139
    dowhilestmt                    shift and go to state 140
    whilestmt                      shift and go to state 141
    forstmt                        shift and go to state 142
    matchif                        shift and go to state 143
    assigstmt                      shift and go to state 144

state 132

    (46) stmt -> matchstmt .
    ID              reduce using rule 46 (stmt -> matchstmt .)
    IF              reduce using rule 46 (stmt -> matchstmt .)
    LBRACE          reduce using rule 46 (stmt -> matchstmt .)
    RETURN          reduce using rule 46 (stmt -> matchstmt .)
    CONTINUE        reduce using rule 46 (stmt -> matchstmt .)
    BREAK           reduce using rule 46 (stmt -> matchstmt .)
    DO              reduce using rule 46 (stmt -> matchstmt .)
    WHILE           reduce using rule 46 (stmt -> matchstmt .)
    FOR             reduce using rule 46 (stmt -> matchstmt .)
    RBRACE          reduce using rule 46 (stmt -> matchstmt .)
    ELSE            reduce using rule 46 (stmt -> matchstmt .)


state 133

    (47) stmt -> unmatchif .
    ID              reduce using rule 47 (stmt -> unmatchif .)
    IF              reduce using rule 47 (stmt -> unmatchif .)
    LBRACE          reduce using rule 47 (stmt -> unmatchif .)
    RETURN          reduce using rule 47 (stmt -> unmatchif .)
    CONTINUE        reduce using rule 47 (stmt -> unmatchif .)
    BREAK           reduce using rule 47 (stmt -> unmatchif .)
    DO              reduce using rule 47 (stmt -> unmatchif .)
    WHILE           reduce using rule 47 (stmt -> unmatchif .)
    FOR             reduce using rule 47 (stmt -> unmatchif .)
    RBRACE          reduce using rule 47 (stmt -> unmatchif .)
    ELSE            reduce using rule 47 (stmt -> unmatchif .)


state 134

    (6) vardecl -> ID . subvardecl exp0 SEMICOLON
    (7) vardecl -> ID . subvardecl2
    (8) vardecl -> ID . COLON typeof SEMICOLON
    (75) callstmt -> ID . LPAREN explist RPAREN SEMICOLON
    (58) assigstmt -> ID . ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> ID . LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    (9) subvardecl -> . COLON typeof ASSIGNMENT
    (10) subvardecl -> . COMMA ID subvardecl exp0 COMMA
    (11) subvardecl2 -> . COMMA ID subvardecl3
    COLON           shift and go to state 165
    LPAREN          shift and go to state 166
    ASSIGNMENT      shift and go to state 167
    LBRACKET        shift and go to state 168
    COMMA           shift and go to state 11

    subvardecl                     shift and go to state 9
    subvardecl2                    shift and go to state 10

state 135

    (48) matchstmt -> blockstmt .
    ID              reduce using rule 48 (matchstmt -> blockstmt .)
    IF              reduce using rule 48 (matchstmt -> blockstmt .)
    LBRACE          reduce using rule 48 (matchstmt -> blockstmt .)
    RETURN          reduce using rule 48 (matchstmt -> blockstmt .)
    CONTINUE        reduce using rule 48 (matchstmt -> blockstmt .)
    BREAK           reduce using rule 48 (matchstmt -> blockstmt .)
    DO              reduce using rule 48 (matchstmt -> blockstmt .)
    WHILE           reduce using rule 48 (matchstmt -> blockstmt .)
    FOR             reduce using rule 48 (matchstmt -> blockstmt .)
    RBRACE          reduce using rule 48 (matchstmt -> blockstmt .)
    ELSE            reduce using rule 48 (matchstmt -> blockstmt .)


state 136

    (49) matchstmt -> callstmt .
    ID              reduce using rule 49 (matchstmt -> callstmt .)
    IF              reduce using rule 49 (matchstmt -> callstmt .)
    LBRACE          reduce using rule 49 (matchstmt -> callstmt .)
    RETURN          reduce using rule 49 (matchstmt -> callstmt .)
    CONTINUE        reduce using rule 49 (matchstmt -> callstmt .)
    BREAK           reduce using rule 49 (matchstmt -> callstmt .)
    DO              reduce using rule 49 (matchstmt -> callstmt .)
    WHILE           reduce using rule 49 (matchstmt -> callstmt .)
    FOR             reduce using rule 49 (matchstmt -> callstmt .)
    RBRACE          reduce using rule 49 (matchstmt -> callstmt .)
    ELSE            reduce using rule 49 (matchstmt -> callstmt .)


state 137

    (50) matchstmt -> retstmt .
    ID              reduce using rule 50 (matchstmt -> retstmt .)
    IF              reduce using rule 50 (matchstmt -> retstmt .)
    LBRACE          reduce using rule 50 (matchstmt -> retstmt .)
    RETURN          reduce using rule 50 (matchstmt -> retstmt .)
    CONTINUE        reduce using rule 50 (matchstmt -> retstmt .)
    BREAK           reduce using rule 50 (matchstmt -> retstmt .)
    DO              reduce using rule 50 (matchstmt -> retstmt .)
    WHILE           reduce using rule 50 (matchstmt -> retstmt .)
    FOR             reduce using rule 50 (matchstmt -> retstmt .)
    RBRACE          reduce using rule 50 (matchstmt -> retstmt .)
    ELSE            reduce using rule 50 (matchstmt -> retstmt .)


state 138

    (51) matchstmt -> contistmt .
    ID              reduce using rule 51 (matchstmt -> contistmt .)
    IF              reduce using rule 51 (matchstmt -> contistmt .)
    LBRACE          reduce using rule 51 (matchstmt -> contistmt .)
    RETURN          reduce using rule 51 (matchstmt -> contistmt .)
    CONTINUE        reduce using rule 51 (matchstmt -> contistmt .)
    BREAK           reduce using rule 51 (matchstmt -> contistmt .)
    DO              reduce using rule 51 (matchstmt -> contistmt .)
    WHILE           reduce using rule 51 (matchstmt -> contistmt .)
    FOR             reduce using rule 51 (matchstmt -> contistmt .)
    RBRACE          reduce using rule 51 (matchstmt -> contistmt .)
    ELSE            reduce using rule 51 (matchstmt -> contistmt .)


state 139

    (52) matchstmt -> breakstmt .
    ID              reduce using rule 52 (matchstmt -> breakstmt .)
    IF              reduce using rule 52 (matchstmt -> breakstmt .)
    LBRACE          reduce using rule 52 (matchstmt -> breakstmt .)
    RETURN          reduce using rule 52 (matchstmt -> breakstmt .)
    CONTINUE        reduce using rule 52 (matchstmt -> breakstmt .)
    BREAK           reduce using rule 52 (matchstmt -> breakstmt .)
    DO              reduce using rule 52 (matchstmt -> breakstmt .)
    WHILE           reduce using rule 52 (matchstmt -> breakstmt .)
    FOR             reduce using rule 52 (matchstmt -> breakstmt .)
    RBRACE          reduce using rule 52 (matchstmt -> breakstmt .)
    ELSE            reduce using rule 52 (matchstmt -> breakstmt .)


state 140

    (53) matchstmt -> dowhilestmt .
    ID              reduce using rule 53 (matchstmt -> dowhilestmt .)
    IF              reduce using rule 53 (matchstmt -> dowhilestmt .)
    LBRACE          reduce using rule 53 (matchstmt -> dowhilestmt .)
    RETURN          reduce using rule 53 (matchstmt -> dowhilestmt .)
    CONTINUE        reduce using rule 53 (matchstmt -> dowhilestmt .)
    BREAK           reduce using rule 53 (matchstmt -> dowhilestmt .)
    DO              reduce using rule 53 (matchstmt -> dowhilestmt .)
    WHILE           reduce using rule 53 (matchstmt -> dowhilestmt .)
    FOR             reduce using rule 53 (matchstmt -> dowhilestmt .)
    RBRACE          reduce using rule 53 (matchstmt -> dowhilestmt .)
    ELSE            reduce using rule 53 (matchstmt -> dowhilestmt .)


state 141

    (54) matchstmt -> whilestmt .
    ID              reduce using rule 54 (matchstmt -> whilestmt .)
    IF              reduce using rule 54 (matchstmt -> whilestmt .)
    LBRACE          reduce using rule 54 (matchstmt -> whilestmt .)
    RETURN          reduce using rule 54 (matchstmt -> whilestmt .)
    CONTINUE        reduce using rule 54 (matchstmt -> whilestmt .)
    BREAK           reduce using rule 54 (matchstmt -> whilestmt .)
    DO              reduce using rule 54 (matchstmt -> whilestmt .)
    WHILE           reduce using rule 54 (matchstmt -> whilestmt .)
    FOR             reduce using rule 54 (matchstmt -> whilestmt .)
    RBRACE          reduce using rule 54 (matchstmt -> whilestmt .)
    ELSE            reduce using rule 54 (matchstmt -> whilestmt .)


state 142

    (55) matchstmt -> forstmt .
    ID              reduce using rule 55 (matchstmt -> forstmt .)
    IF              reduce using rule 55 (matchstmt -> forstmt .)
    LBRACE          reduce using rule 55 (matchstmt -> forstmt .)
    RETURN          reduce using rule 55 (matchstmt -> forstmt .)
    CONTINUE        reduce using rule 55 (matchstmt -> forstmt .)
    BREAK           reduce using rule 55 (matchstmt -> forstmt .)
    DO              reduce using rule 55 (matchstmt -> forstmt .)
    WHILE           reduce using rule 55 (matchstmt -> forstmt .)
    FOR             reduce using rule 55 (matchstmt -> forstmt .)
    RBRACE          reduce using rule 55 (matchstmt -> forstmt .)
    ELSE            reduce using rule 55 (matchstmt -> forstmt .)


state 143

    (56) matchstmt -> matchif .
    ID              reduce using rule 56 (matchstmt -> matchif .)
    IF              reduce using rule 56 (matchstmt -> matchif .)
    LBRACE          reduce using rule 56 (matchstmt -> matchif .)
    RETURN          reduce using rule 56 (matchstmt -> matchif .)
    CONTINUE        reduce using rule 56 (matchstmt -> matchif .)
    BREAK           reduce using rule 56 (matchstmt -> matchif .)
    DO              reduce using rule 56 (matchstmt -> matchif .)
    WHILE           reduce using rule 56 (matchstmt -> matchif .)
    FOR             reduce using rule 56 (matchstmt -> matchif .)
    RBRACE          reduce using rule 56 (matchstmt -> matchif .)
    ELSE            reduce using rule 56 (matchstmt -> matchif .)


state 144

    (57) matchstmt -> assigstmt .
    ID              reduce using rule 57 (matchstmt -> assigstmt .)
    IF              reduce using rule 57 (matchstmt -> assigstmt .)
    LBRACE          reduce using rule 57 (matchstmt -> assigstmt .)
    RETURN          reduce using rule 57 (matchstmt -> assigstmt .)
    CONTINUE        reduce using rule 57 (matchstmt -> assigstmt .)
    BREAK           reduce using rule 57 (matchstmt -> assigstmt .)
    DO              reduce using rule 57 (matchstmt -> assigstmt .)
    WHILE           reduce using rule 57 (matchstmt -> assigstmt .)
    FOR             reduce using rule 57 (matchstmt -> assigstmt .)
    RBRACE          reduce using rule 57 (matchstmt -> assigstmt .)
    ELSE            reduce using rule 57 (matchstmt -> assigstmt .)


state 145

    (61) unmatchif -> IF . LPAREN exp0 RPAREN stmt
    (62) unmatchif -> IF . LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (60) matchif -> IF . LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    LPAREN          shift and go to state 169


state 146

    (73) retstmt -> RETURN . SEMICOLON
    (74) retstmt -> RETURN . exp0 SEMICOLON
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    SEMICOLON       shift and go to state 170
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 171
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 147

    (72) contistmt -> CONTINUE . SEMICOLON
    SEMICOLON       shift and go to state 172


state 148

    (71) breakstmt -> BREAK . SEMICOLON
    SEMICOLON       shift and go to state 173


state 149

    (70) dowhilestmt -> DO . blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    LBRACE          shift and go to state 110

    blockstmt                      shift and go to state 174

state 150

    (68) whilestmt -> WHILE . whilecondi stmt
    (69) whilecondi -> . LPAREN exp0 RPAREN
    LPAREN          shift and go to state 176

    whilecondi                     shift and go to state 175

state 151

    (63) forstmt -> FOR . LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    LPAREN          shift and go to state 177


state 152

    (31) paramdecl -> LPAREN paramlist RPAREN .
    INHERIT         reduce using rule 31 (paramdecl -> LPAREN paramlist RPAREN .)
    LBRACE          reduce using rule 31 (paramdecl -> LPAREN paramlist RPAREN .)


state 153

    (35) paramprime -> param COMMA . paramprime
    (34) paramprime -> . param
    (35) paramprime -> . param COMMA paramprime
    (36) param -> . OUT ID COLON typeof
    (37) param -> . INHERIT ID COLON typeof
    (38) param -> . ID COLON typeof
    (39) param -> . INHERIT OUT ID COLON typeof
    OUT             shift and go to state 115
    INHERIT         shift and go to state 117
    ID              shift and go to state 116

    param                          shift and go to state 114
    paramprime                     shift and go to state 178

state 154

    (36) param -> OUT ID . COLON typeof
    COLON           shift and go to state 179


state 155

    (38) param -> ID COLON . typeof
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 16
    ARRAY           shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    typeof                         shift and go to state 180
    arrtype                        shift and go to state 14
    atotype                        shift and go to state 15

state 156

    (37) param -> INHERIT ID . COLON typeof
    COLON           shift and go to state 181


state 157

    (39) param -> INHERIT OUT . ID COLON typeof
    ID              shift and go to state 182


state 158

    (22) arrtype -> ARRAY LBRACKET dime RBRACKET OF . atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    atotype                        shift and go to state 183

state 159

    (24) dime -> INTLIT COMMA dime .
    RBRACKET        reduce using rule 24 (dime -> INTLIT COMMA dime .)


state 160

    (9) subvardecl -> COLON typeof . ASSIGNMENT
    ASSIGNMENT      shift and go to state 51


state 161

    (29) funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt .
    ID              reduce using rule 29 (funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt .)
    $end            reduce using rule 29 (funcdecl -> ID COLON FUNCTION returntype paramdecl INHERIT ID blockstmt .)


state 162

    (76) blockstmt -> LBRACE stmtlist RBRACE .
    ID              reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    $end            reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    IF              reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    LBRACE          reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    RETURN          reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    CONTINUE        reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    BREAK           reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    DO              reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    WHILE           reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    FOR             reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    RBRACE          reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)
    ELSE            reduce using rule 76 (blockstmt -> LBRACE stmtlist RBRACE .)


state 163

    (45) stmtprime -> stmt stmtlist .
    RBRACE          reduce using rule 45 (stmtprime -> stmt stmtlist .)


state 164

    (44) stmtprime -> vardecl stmtlist .
    RBRACE          reduce using rule 44 (stmtprime -> vardecl stmtlist .)


state 165

    (8) vardecl -> ID COLON . typeof SEMICOLON
    (9) subvardecl -> COLON . typeof ASSIGNMENT
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 16
    ARRAY           shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    typeof                         shift and go to state 13
    arrtype                        shift and go to state 14
    atotype                        shift and go to state 15

state 166

    (75) callstmt -> ID LPAREN . explist RPAREN SEMICOLON
    (79) explist -> . empty
    (80) explist -> . expprime
    (118) empty -> .
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    RPAREN          reduce using rule 118 (empty -> .)
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    explist                        shift and go to state 184
    empty                          shift and go to state 74
    expprime                       shift and go to state 75
    exp0                           shift and go to state 76
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 167

    (58) assigstmt -> ID ASSIGNMENT . exp0 SEMICOLON
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 185
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 168

    (59) assigstmt -> ID LBRACKET . expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    (81) expprime -> . exp0
    (82) expprime -> . exp0 COMMA expprime
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    expprime                       shift and go to state 186
    exp0                           shift and go to state 76
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 169

    (61) unmatchif -> IF LPAREN . exp0 RPAREN stmt
    (62) unmatchif -> IF LPAREN . exp0 RPAREN matchstmt ELSE unmatchif
    (60) matchif -> IF LPAREN . exp0 RPAREN matchstmt ELSE matchstmt
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 187
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 170

    (73) retstmt -> RETURN SEMICOLON .
    ID              reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    IF              reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    DO              reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 73 (retstmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 73 (retstmt -> RETURN SEMICOLON .)


state 171

    (74) retstmt -> RETURN exp0 . SEMICOLON
    SEMICOLON       shift and go to state 188


state 172

    (72) contistmt -> CONTINUE SEMICOLON .
    ID              reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    DO              reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 72 (contistmt -> CONTINUE SEMICOLON .)


state 173

    (71) breakstmt -> BREAK SEMICOLON .
    ID              reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    IF              reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    DO              reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 71 (breakstmt -> BREAK SEMICOLON .)


state 174

    (70) dowhilestmt -> DO blockstmt . WHILE LPAREN exp0 RPAREN SEMICOLON
    WHILE           shift and go to state 189


state 175

    (68) whilestmt -> WHILE whilecondi . stmt
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    IF              shift and go to state 145
    LBRACE          shift and go to state 110
    ID              shift and go to state 191
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    DO              shift and go to state 149
    WHILE           shift and go to state 150
    FOR             shift and go to state 151

    stmt                           shift and go to state 190
    matchstmt                      shift and go to state 132
    unmatchif                      shift and go to state 133
    blockstmt                      shift and go to state 135
    callstmt                       shift and go to state 136
    retstmt                        shift and go to state 137
    contistmt                      shift and go to state 138
    breakstmt                      shift and go to state 139
    dowhilestmt                    shift and go to state 140
    whilestmt                      shift and go to state 141
    forstmt                        shift and go to state 142
    matchif                        shift and go to state 143
    assigstmt                      shift and go to state 144

state 176

    (69) whilecondi -> LPAREN . exp0 RPAREN
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 192
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 177

    (63) forstmt -> FOR LPAREN . scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (64) scaladecl -> . scalavar ASSIGNMENT exp0
    (65) scalavar -> . ID
    ID              shift and go to state 195

    scaladecl                      shift and go to state 193
    scalavar                       shift and go to state 194

state 178

    (35) paramprime -> param COMMA paramprime .
    RPAREN          reduce using rule 35 (paramprime -> param COMMA paramprime .)


state 179

    (36) param -> OUT ID COLON . typeof
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 16
    ARRAY           shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    typeof                         shift and go to state 196
    arrtype                        shift and go to state 14
    atotype                        shift and go to state 15

state 180

    (38) param -> ID COLON typeof .
    COMMA           reduce using rule 38 (param -> ID COLON typeof .)
    RPAREN          reduce using rule 38 (param -> ID COLON typeof .)


state 181

    (37) param -> INHERIT ID COLON . typeof
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 16
    ARRAY           shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    typeof                         shift and go to state 197
    arrtype                        shift and go to state 14
    atotype                        shift and go to state 15

state 182

    (39) param -> INHERIT OUT ID . COLON typeof
    COLON           shift and go to state 198


state 183

    (22) arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .
    SEMICOLON       reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)
    ASSIGNMENT      reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)
    LPAREN          reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)
    COMMA           reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)
    RPAREN          reduce using rule 22 (arrtype -> ARRAY LBRACKET dime RBRACKET OF atotype .)


state 184

    (75) callstmt -> ID LPAREN explist . RPAREN SEMICOLON
    RPAREN          shift and go to state 199


state 185

    (58) assigstmt -> ID ASSIGNMENT exp0 . SEMICOLON
    SEMICOLON       shift and go to state 200


state 186

    (59) assigstmt -> ID LBRACKET expprime . RBRACKET ASSIGNMENT exp0 SEMICOLON
    RBRACKET        shift and go to state 201


state 187

    (61) unmatchif -> IF LPAREN exp0 . RPAREN stmt
    (62) unmatchif -> IF LPAREN exp0 . RPAREN matchstmt ELSE unmatchif
    (60) matchif -> IF LPAREN exp0 . RPAREN matchstmt ELSE matchstmt
    RPAREN          shift and go to state 202


state 188

    (74) retstmt -> RETURN exp0 SEMICOLON .
    ID              reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    IF              reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    LBRACE          reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    RETURN          reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    CONTINUE        reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    BREAK           reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    DO              reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    WHILE           reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    FOR             reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    RBRACE          reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)
    ELSE            reduce using rule 74 (retstmt -> RETURN exp0 SEMICOLON .)


state 189

    (70) dowhilestmt -> DO blockstmt WHILE . LPAREN exp0 RPAREN SEMICOLON
    LPAREN          shift and go to state 203


state 190

    (68) whilestmt -> WHILE whilecondi stmt .
    ID              reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    IF              reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    LBRACE          reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    RETURN          reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    CONTINUE        reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    BREAK           reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    DO              reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    WHILE           reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    FOR             reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    RBRACE          reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)
    ELSE            reduce using rule 68 (whilestmt -> WHILE whilecondi stmt .)


state 191

    (75) callstmt -> ID . LPAREN explist RPAREN SEMICOLON
    (58) assigstmt -> ID . ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> ID . LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    LPAREN          shift and go to state 166
    ASSIGNMENT      shift and go to state 167
    LBRACKET        shift and go to state 168


state 192

    (69) whilecondi -> LPAREN exp0 . RPAREN
    RPAREN          shift and go to state 204


state 193

    (63) forstmt -> FOR LPAREN scaladecl . COMMA condifor COMMA updatefor RPAREN stmt
    COMMA           shift and go to state 205


state 194

    (64) scaladecl -> scalavar . ASSIGNMENT exp0
    ASSIGNMENT      shift and go to state 206


state 195

    (65) scalavar -> ID .
    ASSIGNMENT      reduce using rule 65 (scalavar -> ID .)


state 196

    (36) param -> OUT ID COLON typeof .
    COMMA           reduce using rule 36 (param -> OUT ID COLON typeof .)
    RPAREN          reduce using rule 36 (param -> OUT ID COLON typeof .)


state 197

    (37) param -> INHERIT ID COLON typeof .
    COMMA           reduce using rule 37 (param -> INHERIT ID COLON typeof .)
    RPAREN          reduce using rule 37 (param -> INHERIT ID COLON typeof .)


state 198

    (39) param -> INHERIT OUT ID COLON . typeof
    (15) typeof -> . arrtype
    (16) typeof -> . atotype
    (17) typeof -> . AUTO
    (22) arrtype -> . ARRAY LBRACKET dime RBRACKET OF atotype
    (18) atotype -> . STRING
    (19) atotype -> . FLOAT
    (20) atotype -> . INTEGER
    (21) atotype -> . BOOLEAN
    AUTO            shift and go to state 16
    ARRAY           shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20
    BOOLEAN         shift and go to state 21

    typeof                         shift and go to state 207
    arrtype                        shift and go to state 14
    atotype                        shift and go to state 15

state 199

    (75) callstmt -> ID LPAREN explist RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 208


state 200

    (58) assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .
    ID              reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    IF              reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    LBRACE          reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    RETURN          reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    CONTINUE        reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    BREAK           reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    DO              reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    WHILE           reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    FOR             reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    RBRACE          reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)
    ELSE            reduce using rule 58 (assigstmt -> ID ASSIGNMENT exp0 SEMICOLON .)


state 201

    (59) assigstmt -> ID LBRACKET expprime RBRACKET . ASSIGNMENT exp0 SEMICOLON
    ASSIGNMENT      shift and go to state 209


state 202

    (61) unmatchif -> IF LPAREN exp0 RPAREN . stmt
    (62) unmatchif -> IF LPAREN exp0 RPAREN . matchstmt ELSE unmatchif
    (60) matchif -> IF LPAREN exp0 RPAREN . matchstmt ELSE matchstmt
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    IF              shift and go to state 145
    LBRACE          shift and go to state 110
    ID              shift and go to state 191
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    DO              shift and go to state 149
    WHILE           shift and go to state 150
    FOR             shift and go to state 151

    stmt                           shift and go to state 210
    matchstmt                      shift and go to state 211
    unmatchif                      shift and go to state 133
    blockstmt                      shift and go to state 135
    callstmt                       shift and go to state 136
    retstmt                        shift and go to state 137
    contistmt                      shift and go to state 138
    breakstmt                      shift and go to state 139
    dowhilestmt                    shift and go to state 140
    whilestmt                      shift and go to state 141
    forstmt                        shift and go to state 142
    matchif                        shift and go to state 143
    assigstmt                      shift and go to state 144

state 203

    (70) dowhilestmt -> DO blockstmt WHILE LPAREN . exp0 RPAREN SEMICOLON
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 212
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 204

    (69) whilecondi -> LPAREN exp0 RPAREN .
    IF              reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    LBRACE          reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    ID              reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    RETURN          reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    CONTINUE        reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    BREAK           reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    DO              reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    WHILE           reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)
    FOR             reduce using rule 69 (whilecondi -> LPAREN exp0 RPAREN .)


state 205

    (63) forstmt -> FOR LPAREN scaladecl COMMA . condifor COMMA updatefor RPAREN stmt
    (66) condifor -> . exp0
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    condifor                       shift and go to state 213
    exp0                           shift and go to state 214
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 206

    (64) scaladecl -> scalavar ASSIGNMENT . exp0
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 215
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 207

    (39) param -> INHERIT OUT ID COLON typeof .
    COMMA           reduce using rule 39 (param -> INHERIT OUT ID COLON typeof .)
    RPAREN          reduce using rule 39 (param -> INHERIT OUT ID COLON typeof .)


state 208

    (75) callstmt -> ID LPAREN explist RPAREN SEMICOLON .
    ID              reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    IF              reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    LBRACE          reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    RETURN          reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    BREAK           reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    DO              reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    WHILE           reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    FOR             reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    RBRACE          reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)
    ELSE            reduce using rule 75 (callstmt -> ID LPAREN explist RPAREN SEMICOLON .)


state 209

    (59) assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT . exp0 SEMICOLON
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    exp0                           shift and go to state 216
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 210

    (61) unmatchif -> IF LPAREN exp0 RPAREN stmt .
    ID              reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    IF              reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    LBRACE          reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    RETURN          reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    CONTINUE        reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    BREAK           reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    DO              reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    WHILE           reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    FOR             reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    RBRACE          reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)
    ELSE            reduce using rule 61 (unmatchif -> IF LPAREN exp0 RPAREN stmt .)


state 211

    (62) unmatchif -> IF LPAREN exp0 RPAREN matchstmt . ELSE unmatchif
    (60) matchif -> IF LPAREN exp0 RPAREN matchstmt . ELSE matchstmt
    (46) stmt -> matchstmt .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 217
    ID              reduce using rule 46 (stmt -> matchstmt .)
    IF              reduce using rule 46 (stmt -> matchstmt .)
    LBRACE          reduce using rule 46 (stmt -> matchstmt .)
    RETURN          reduce using rule 46 (stmt -> matchstmt .)
    CONTINUE        reduce using rule 46 (stmt -> matchstmt .)
    BREAK           reduce using rule 46 (stmt -> matchstmt .)
    DO              reduce using rule 46 (stmt -> matchstmt .)
    WHILE           reduce using rule 46 (stmt -> matchstmt .)
    FOR             reduce using rule 46 (stmt -> matchstmt .)
    RBRACE          reduce using rule 46 (stmt -> matchstmt .)


state 212

    (70) dowhilestmt -> DO blockstmt WHILE LPAREN exp0 . RPAREN SEMICOLON
    RPAREN          shift and go to state 218


state 213

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor . COMMA updatefor RPAREN stmt
    COMMA           shift and go to state 219


state 214

    (66) condifor -> exp0 .
    COMMA           reduce using rule 66 (condifor -> exp0 .)


state 215

    (64) scaladecl -> scalavar ASSIGNMENT exp0 .
    COMMA           reduce using rule 64 (scaladecl -> scalavar ASSIGNMENT exp0 .)


state 216

    (59) assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 . SEMICOLON
    SEMICOLON       shift and go to state 220


state 217

    (62) unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE . unmatchif
    (60) matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE . matchstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    IF              shift and go to state 145
    LBRACE          shift and go to state 110
    ID              shift and go to state 191
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    DO              shift and go to state 149
    WHILE           shift and go to state 150
    FOR             shift and go to state 151

    matchstmt                      shift and go to state 221
    unmatchif                      shift and go to state 222
    blockstmt                      shift and go to state 135
    callstmt                       shift and go to state 136
    retstmt                        shift and go to state 137
    contistmt                      shift and go to state 138
    breakstmt                      shift and go to state 139
    dowhilestmt                    shift and go to state 140
    whilestmt                      shift and go to state 141
    forstmt                        shift and go to state 142
    matchif                        shift and go to state 143
    assigstmt                      shift and go to state 144

state 218

    (70) dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 223


state 219

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA . updatefor RPAREN stmt
    (67) updatefor -> . exp0
    (91) exp0 -> . exp1
    (83) exp1 -> . exp2
    (84) exp1 -> . exp2 EQUAL exp2
    (85) exp1 -> . exp2 NOTEQUAL exp2
    (86) exp1 -> . exp2 LESSTHAN exp2
    (87) exp1 -> . exp2 LEQ exp2
    (88) exp1 -> . exp2 GREATERTHAN exp2
    (89) exp1 -> . exp2 GEQ exp2
    (90) exp1 -> . exp1 DOUBLECOLON exp1
    (92) exp2 -> . exp3
    (93) exp2 -> . exp2 AND exp3
    (94) exp2 -> . exp2 OR exp3
    (101) exp3 -> . exp4
    (95) exp4 -> . exp5
    (96) exp4 -> . exp4 MUL exp5
    (97) exp4 -> . exp4 DIV exp5
    (98) exp4 -> . exp4 MOD exp5
    (99) exp4 -> . exp3 PLUS exp4
    (100) exp4 -> . exp3 MINUS exp4
    (102) exp5 -> . exp6
    (103) exp5 -> . NOT exp5
    (104) exp6 -> . exp7
    (105) exp6 -> . MINUS exp6
    (106) exp7 -> . exp8
    (107) exp7 -> . ID LBRACKET expprime RBRACKET
    (108) exp8 -> . exp9
    (109) exp8 -> . funcall
    (110) exp9 -> . exp10
    (111) exp9 -> . arraylit
    (112) exp9 -> . ID
    (113) exp9 -> . STRINGLIT
    (114) exp9 -> . BOOLEANLIT
    (115) exp9 -> . FLOATLIT
    (116) exp9 -> . INTLIT
    (77) funcall -> . ID LPAREN explist RPAREN
    (117) exp10 -> . LPAREN exp0 RPAREN
    (78) arraylit -> . LBRACE explist RBRACE
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    ID              shift and go to state 22
    STRINGLIT       shift and go to state 38
    BOOLEANLIT      shift and go to state 39
    FLOATLIT        shift and go to state 40
    INTLIT          shift and go to state 41
    LPAREN          shift and go to state 42
    LBRACE          shift and go to state 43

    updatefor                      shift and go to state 224
    exp0                           shift and go to state 225
    exp1                           shift and go to state 24
    exp2                           shift and go to state 25
    exp3                           shift and go to state 26
    exp4                           shift and go to state 27
    exp5                           shift and go to state 28
    exp6                           shift and go to state 30
    exp7                           shift and go to state 32
    exp8                           shift and go to state 33
    exp9                           shift and go to state 34
    funcall                        shift and go to state 35
    exp10                          shift and go to state 36
    arraylit                       shift and go to state 37

state 220

    (59) assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .
    ID              reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    IF              reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    LBRACE          reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    RETURN          reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    CONTINUE        reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    BREAK           reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    DO              reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    WHILE           reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    FOR             reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    RBRACE          reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)
    ELSE            reduce using rule 59 (assigstmt -> ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON .)


state 221

    (60) matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .
    ID              reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    IF              reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    LBRACE          reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    RETURN          reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    CONTINUE        reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    BREAK           reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    DO              reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    WHILE           reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    FOR             reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    RBRACE          reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)
    ELSE            reduce using rule 60 (matchif -> IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt .)


state 222

    (62) unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .
    ID              reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    IF              reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    LBRACE          reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    RETURN          reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    CONTINUE        reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    BREAK           reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    DO              reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    WHILE           reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    FOR             reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    RBRACE          reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)
    ELSE            reduce using rule 62 (unmatchif -> IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif .)


state 223

    (70) dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .
    ID              reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    IF              reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    LBRACE          reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    RETURN          reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    BREAK           reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    DO              reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    WHILE           reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    FOR             reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    RBRACE          reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)
    ELSE            reduce using rule 70 (dowhilestmt -> DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON .)


state 224

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor . RPAREN stmt
    RPAREN          shift and go to state 226


state 225

    (67) updatefor -> exp0 .
    RPAREN          reduce using rule 67 (updatefor -> exp0 .)


state 226

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN . stmt
    (46) stmt -> . matchstmt
    (47) stmt -> . unmatchif
    (48) matchstmt -> . blockstmt
    (49) matchstmt -> . callstmt
    (50) matchstmt -> . retstmt
    (51) matchstmt -> . contistmt
    (52) matchstmt -> . breakstmt
    (53) matchstmt -> . dowhilestmt
    (54) matchstmt -> . whilestmt
    (55) matchstmt -> . forstmt
    (56) matchstmt -> . matchif
    (57) matchstmt -> . assigstmt
    (61) unmatchif -> . IF LPAREN exp0 RPAREN stmt
    (62) unmatchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE unmatchif
    (76) blockstmt -> . LBRACE stmtlist RBRACE
    (75) callstmt -> . ID LPAREN explist RPAREN SEMICOLON
    (73) retstmt -> . RETURN SEMICOLON
    (74) retstmt -> . RETURN exp0 SEMICOLON
    (72) contistmt -> . CONTINUE SEMICOLON
    (71) breakstmt -> . BREAK SEMICOLON
    (70) dowhilestmt -> . DO blockstmt WHILE LPAREN exp0 RPAREN SEMICOLON
    (68) whilestmt -> . WHILE whilecondi stmt
    (63) forstmt -> . FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt
    (60) matchif -> . IF LPAREN exp0 RPAREN matchstmt ELSE matchstmt
    (58) assigstmt -> . ID ASSIGNMENT exp0 SEMICOLON
    (59) assigstmt -> . ID LBRACKET expprime RBRACKET ASSIGNMENT exp0 SEMICOLON
    IF              shift and go to state 145
    LBRACE          shift and go to state 110
    ID              shift and go to state 191
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    DO              shift and go to state 149
    WHILE           shift and go to state 150
    FOR             shift and go to state 151

    stmt                           shift and go to state 227
    matchstmt                      shift and go to state 132
    unmatchif                      shift and go to state 133
    blockstmt                      shift and go to state 135
    callstmt                       shift and go to state 136
    retstmt                        shift and go to state 137
    contistmt                      shift and go to state 138
    breakstmt                      shift and go to state 139
    dowhilestmt                    shift and go to state 140
    whilestmt                      shift and go to state 141
    forstmt                        shift and go to state 142
    matchif                        shift and go to state 143
    assigstmt                      shift and go to state 144

state 227

    (63) forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .
    ID              reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    IF              reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    LBRACE          reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    RETURN          reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    CONTINUE        reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    BREAK           reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    DO              reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    WHILE           reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    FOR             reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    RBRACE          reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)
    ELSE            reduce using rule 63 (forstmt -> FOR LPAREN scaladecl COMMA condifor COMMA updatefor RPAREN stmt .)


Conflicts:

shift/reduce conflict for DOUBLECOLON in state 87 resolved as shift
shift/reduce conflict for MUL in state 97 resolved as shift
shift/reduce conflict for DIV in state 97 resolved as shift
shift/reduce conflict for MOD in state 97 resolved as shift
shift/reduce conflict for MUL in state 98 resolved as shift
shift/reduce conflict for DIV in state 98 resolved as shift
shift/reduce conflict for MOD in state 98 resolved as shift
shift/reduce conflict for ELSE in state 211 resolved as shift
reduce/reduce conflict in state 97 resolved using rule exp4 -> exp3 PLUS exp4
rejected rule (exp3 -> exp4) in state 97
reduce/reduce conflict in state 98 resolved using rule exp4 -> exp3 MINUS exp4
rejected rule (exp3 -> exp4) in state 98
reduce/reduce conflict in state 130 resolved using rule stmtprime -> stmt
rejected rule (empty -> <empty>) in state 130
reduce/reduce conflict in state 131 resolved using rule stmtprime -> vardecl
rejected rule (empty -> <empty>) in state 131